<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>El acto de respirar - Presencia, pausa y cuidado</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #fff;
      font-family: Arial, sans-serif;
    }

    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* Tamaño fijo para controlar límites visuales */
      width: 400px;
      height: 300px;
      max-width: 90vw;
      max-height: 70vh;
    }

    .controls {
      position: absolute;
      bottom: 30px;
      z-index: 10;
      text-align: center;
      width: 100%;
      display: flex;
      justify-content: center;
      pointer-events: auto;
    }

    button {
      background-color: rgba(255, 255, 255, 0.2);
      color: #fff;
      border: 1px solid #fff;
      padding: 10px 20px;
      border-radius: 30px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
      outline: none;
    }

    button:hover {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .info {
      position: absolute;
      top: 30px;
      text-align: center;
      max-width: 600px;
      padding: 0 20px;
      font-size: 18px;
      line-height: 1.5;
      opacity: 0.8;
      pointer-events: none;
      user-select: none;
    }

    .info h1 {
      font-weight: normal;
      font-size: 24px;
      margin-bottom: 10px;
    }

    .info p {
      margin-bottom: 5px;
    }

    .hidden {
      display: none;
    }

    .volume-indicator {
      width: 50px;
      height: 10px;
      background-color: rgba(255, 255, 255, 0.2);
      margin-left: 15px;
      border-radius: 5px;
      overflow: hidden;
    }

    .volume-level {
      height: 100%;
      width: 0%;
      background-color: rgba(255, 255, 255, 0.8);
      transition: width 0.1s;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="info">
      <h1>El acto de respirar como gesto de presencia, pausa y cuidado</h1>
      <p>Haz clic en el botón y respira para dar vida a la tela con tu aliento.</p>
    </div>

    <canvas id="canvas" width="400" height="300"></canvas>

    <div class="controls">
      <button id="mic-button">Activar Micrófono</button>
      <div class="volume-indicator hidden" id="volume-indicator">
        <div class="volume-level" id="volume-level"></div>
      </div>
    </div>
  </div>

  <script>
    // Configuración del canvas y la simulación
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const micButton = document.getElementById('mic-button');
    const volumeIndicator = document.getElementById('volume-indicator');
    const volumeLevel = document.getElementById('volume-level');

    // Variables para el micrófono
    let audioContext;
    let analyzer;
    let microphone;
    let micActive = false;
    let dataArray;

    // Configuración de la simulación de tela
    const clothWidth = 400;
    const clothHeight = 300;
    const numPointsX = 30;
    const numPointsY = 20;
    const restDistance = clothWidth / numPointsX;

    // Clase Punto para la simulación de tela
    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.originalX = x;
        this.originalY = y;
        this.vx = 0;
        this.vy = 0;
        this.pinned = false;
        this.mass = 1;
      }
    }

    // Clase tela para simulación
    class Cloth {
      constructor() {
        this.points = [];

        // Crear puntos de la tela
        for (let y = 0; y <= numPointsY; y++) {
          for (let x = 0; x <= numPointsX; x++) {
            const u = x / numPointsX;
            const v = y / numPointsY;

            // Posición inicial en forma de curva suave
            const px = clothWidth * u;
            const py = clothHeight * v;

            const point = new Point(px, py);

            // Fijar solo los puntos superiores para que cuelgue
            if (y === 0) {
              point.pinned = true;
            }

            this.points.push(point);
          }
        }

        // Generar el índice para acceder a los puntos fácilmente
        this.getPoint = (x, y) => this.points[y * (numPointsX + 1) + x];

        // Conectar puntos con restricciones elásticas
        this.constraints = [];

        // Restricciones estructurales horizontales
        for (let y = 0; y <= numPointsY; y++) {
          for (let x = 0; x < numPointsX; x++) {
            this.constraints.push({
              p1: this.getPoint(x, y),
              p2: this.getPoint(x + 1, y),
              distance: restDistance,
            });
          }
        }

        // Restricciones estructurales verticales
        for (let x = 0; x <= numPointsX; x++) {
          for (let y = 0; y < numPointsY; y++) {
            this.constraints.push({
              p1: this.getPoint(x, y),
              p2: this.getPoint(x, y + 1),
              distance: restDistance,
            });
          }
        }

        // Restricciones de corte diagonal 1
        for (let y = 0; y < numPointsY; y++) {
          for (let x = 0; x < numPointsX; x++) {
            this.constraints.push({
              p1: this.getPoint(x, y),
              p2: this.getPoint(x + 1, y + 1),
              distance: Math.sqrt(restDistance * restDistance * 2),
            });
          }
        }

        // Restricciones de corte diagonal 2
        for (let y = 0; y < numPointsY; y++) {
          for (let x = 0; x < numPointsX; x++) {
            this.constraints.push({
              p1: this.getPoint(x + 1, y),
              p2: this.getPoint(x, y + 1),
              distance: Math.sqrt(restDistance * restDistance * 2),
            });
          }
        }
      }

      update(dt) {
        // Constantes físicas
        const GRAVITY = 0.0981 * dt;
        const DAMPING = 0.97;

        // Aplicar fuerzas
        for (let i = 0; i < this.points.length; i++) {
          const point = this.points[i];
          if (!point.pinned) {
            // Acumular fuerzas
            point.vy += GRAVITY;

            // Verlet integration
            const prevX = point.x;
            const prevY = point.y;

            point.x += point.vx;
            point.y += point.vy;

            // Limitar extensión vertical para evitar que la tela se estire demasiado
            const maxY = point.originalY + 50; // límite hacia abajo (50px)
            if (point.y > maxY) {
              point.y = maxY;
              point.vy *= -0.3; // rebote amortiguado
            }

            // Actualizar velocidades con amortiguación
            point.vx = (point.x - prevX) * DAMPING;
            point.vy = (point.y - prevY) * DAMPING;
          }
        }

        // Resolver restricciones
        const iterations = 15;
        for (let i = 0; i < iterations; i++) {
          for (let j = 0; j < this.constraints.length; j++) {
            const constraint = this.constraints[j];
            const p1 = constraint.p1;
            const p2 = constraint.p2;

            // Cálculo de la distancia actual
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const currentDistance = Math.sqrt(dx * dx + dy * dy);

            if (currentDistance > 0) {
              // Calcular dirección
              const diff = (constraint.distance - currentDistance) / currentDistance;

              // Distribuir corrección
              const percent1 = p1.pinned ? 0 : 0.5;
              const percent2 = p2.pinned ? 0 : 0.5;

              const offsetX = dx * diff;
              const offsetY = dy * diff;

              p1.x -= offsetX * percent1;
              p1.y -= offsetY * percent1;

              p2.x += offsetX * percent2;
              p2.y += offsetY * percent2;
            }
          }
        }
      }

      applyWindForce(forceX, forceY) {
        // Aplicar fuerzas de viento a todos los puntos
        for (let i = 0; i < this.points.length; i++) {
          const point = this.points[i];
          if (!point.pinned) {
            // Añadir un pequeño componente aleatorio para simular turbulencia
            const randomX = (Math.random() - 0.5) * 0.05;
            const randomY = (Math.random() - 0.5) * 0.05;

            point.vx += forceX + randomX;
            point.vy += forceY + randomY;
          }
        }
      }

      draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Dibujar la tela con degradado suave
        for (let y = 0; y < numPointsY; y++) {
          for (let x = 0; x < numPointsX; x++) {
            const p1 = this.getPoint(x, y);
            const p2 = this.getPoint(x + 1, y);
            const p3 = this.getPoint(x + 1, y + 1);
            const p4 = this.getPoint(x, y + 1);

            // Crear gradiente para simular sombras
            const centerX = (p1.x + p2.x + p3.x + p4.x) / 4;
            const centerY = (p1.y + p2.y + p3.y + p4.y) / 4;

            // Calcular normal aproximada para efectos de iluminación
            const nx = p3.y - p1.y;
            const ny = -(p3.x - p1.x);
            const norm = Math.sqrt(nx * nx + ny * ny);

            // Normalizar normal
            const normalX = nx / norm;
            const normalY = ny / norm;

            // Calcular valor de iluminación basado en la normal
            const lightX = 0.5;
            const lightY = -1;
            const lightIntensity = (normalX * lightX + normalY * lightY) * 0.5 + 0.5;

            // Color basado en iluminación
            const brightness = Math.floor(210 + lightIntensity * 45);

            // Dibujar cuadrilátero
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.lineTo(p4.x, p4.y);
            ctx.closePath();

            // Gradiente radial para simular pliegues y ondulaciones
            const gradient = ctx.createRadialGradient(
              centerX,
              centerY,
              0,
              centerX,
              centerY,
              restDistance * 2
            );

            gradient.addColorStop(0, `rgba(${brightness}, ${brightness}, ${brightness}, 0.9)`);
            gradient.addColorStop(1, `rgba(${brightness - 20}, ${brightness - 20}, ${brightness - 20}, 0.85)`);

            ctx.fillStyle = gradient;
            ctx.fill();

            // Líneas muy suaves para simular pliegues
            ctx.strokeStyle = `rgba(255, 255, 255, 0.06)`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
        }
      }
    }

    // Crear tela
    const cloth = new Cloth();

    // Función para inicializar el micrófono
    function initMicrophone() {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices
          .getUserMedia({ audio: true, video: false })
          .then(function (stream) {
            // Configurar el análisis de audio
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            microphone = audioContext.createMediaStreamSource(stream);
            analyzer = audioContext.createAnalyser();
            analyzer.fftSize = 256;
            microphone.connect(analyzer);

            dataArray = new Uint8Array(analyzer.frequencyBinCount);

            micActive = true;
            micButton.textContent = "Micrófono activado";
            volumeIndicator.classList.remove("hidden");
          })
          .catch(function (err) {
            console.log("Error al acceder al micrófono: " + err);
            alert("No se pudo acceder al micrófono. Por favor, verifica los permisos.");
          });
      } else {
        alert("Tu navegador no soporta acceso al micrófono.");
      }
    }

    // Listener para el botón de micrófono
    micButton.addEventListener("click", function () {
      if (!micActive) {
        initMicrophone();
      } else {
        // Desactivar micrófono si ya está activo
        micActive = false;
        if (microphone) {
          microphone.disconnect();
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        micButton.textContent = "Activar Micrófono";
        volumeIndicator.classList.add("hidden");
      }
    });

    // Variables para el bucle de animación
    let lastTime = performance.now();

    // Función de animación
    function animate() {
      const currentTime = performance.now();
      const deltaTime = (currentTime - lastTime) / 16; // Normalizado a 60 FPS
      lastTime = currentTime;

      // Procesar entrada de micrófono si está activo
      let micLevel = 0;

      if (micActive && analyzer) {
        analyzer.getByteFrequencyData(dataArray);

        // Calcular volumen promedio
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        micLevel = sum / dataArray.length / 255;

        // Actualizar indicador visual
        volumeLevel.style.width = micLevel * 100 + "%";

        // Aplicar fuerza de "respiración" a la tela
        const breathForce = micLevel * 0.15;

        // Crear efecto de ondulación desde diferentes direcciones
        const time = currentTime * 0.001;
        const waveX = Math.sin(time) * breathForce;
        const waveY = Math.cos(time) * breathForce * 0.5;

        cloth.applyWindForce(waveX, waveY);
      } else {
        // Animación suave incluso sin micrófono
        const time = currentTime * 0.001;
        const gentleForceX = Math.sin(time * 0.7) * 0.01;
        const gentleForceY = Math.cos(time * 0.5) * 0.007;

        cloth.applyWindForce(gentleForceX, gentleForceY);
        volumeLevel.style.width = "0%";
      }

      // Actualizar simulación
      cloth.update(deltaTime);

      // Dibujar tela
      cloth.draw();

      // Continuar animación
      requestAnimationFrame(animate);
    }

    // Iniciar animación
    animate();
  </script>
</body>
</html>
