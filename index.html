<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tela Reactiva al Audio - Corregida</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: Arial, sans-serif;
            cursor: pointer;
            touch-action: none;
        }

        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }

        #start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
        }
        
        #feedback {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 14px;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <button id="start-button">Activar Micrófono</button>
    <div id="feedback"></div>
    <script>
        // Configuración del canvas
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('start-button');
        const feedback = document.getElementById('feedback');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.style.touchAction = 'none';

        // Tela - Aumentada densidad para mayor detalle
        const clothWidth = 450;
        const clothHeight = 350;
        const numPointsX = 40; // Más puntos para mayor detalle
        const numPointsY = 30; // Más puntos para mayor detalle
        const restDistance = clothWidth / numPointsX;

        // Variables físicas ajustables
        const GRAVITY_STRENGTH = 0.08;
        const DAMPING = 0.985; // Mayor valor para simular tejido más ligero
        const CONSTRAINT_ITERATIONS = 15; // Más iteraciones para mayor estabilidad

        // Variables para simular interacción del viento
        let time = 0;
        let isFirstRender = true;

        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.originalX = x;
                this.originalY = y;
                this.vx = 0;
                this.vy = 0;
                this.pinned = false;
                this.mass = 1;
                // Propiedades para simulación de rozamiento
                this.friction = 0.99;
                this.windFriction = 0.2 + Math.random() * 0.1; // Rozamiento variable para cada punto
            }
            
            // Método para añadir fuerza
            addForce(fx, fy) {
                this.vx += fx / this.mass;
                this.vy += fy / this.mass;
            }
        }

        class Cloth {
            constructor() {
                this.points = [];
                
                // Crear puntos de la tela con una ligera variación para naturalidad
                for (let y = 0; y <= numPointsY; y++) {
                    for (let x = 0; x <= numPointsX; x++) {
                        const u = x / numPointsX;
                        const v = y / numPointsY;

                        // Pequeña variación para posición inicial más natural
                        const variationX = (Math.random() - 0.5) * 2;
                        const variationY = (Math.random() - 0.5) * 2;

                        // Posición inicial con forma ondulada suave
                        const px = canvas.width / 2 - clothWidth / 2 + clothWidth * u + variationX;
                        const py = canvas.height / 2 - clothHeight / 2 + clothHeight * v + variationY;

                        const point = new Point(px, py);

                        // Fijar puntos superiores para que cuelgue, pero no todos para más naturalidad
                        if (y === 0 && (x % 3 === 0 || x === 0 || x === numPointsX)) {
                            point.pinned = true;
                        }

                        this.points.push(point);
                    }
                }

                this.constraints = [];
                this.createConstraints();
                
                // Color base para la tela
                this.baseColor = {
                    r: 240,
                    g: 240,
                    b: 245
                };
            }
            
            getPoint(x, y) {
                return this.points[y * (numPointsX + 1) + x];
            }

            createConstraints() {
                // Crear restricciones horizontales
                for (let y = 0; y <= numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y),
                            distance: restDistance,
                            type: 'structural'
                        });
                    }
                }

                // Crear restricciones verticales
                for (let x = 0; x <= numPointsX; x++) {
                    for (let y = 0; y < numPointsY; y++) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x, y + 1),
                            distance: restDistance,
                            type: 'structural'
                        });
                    }
                }
                
                // Agregar restricciones diagonales para simular mejor la resistencia al desgarro
                for (let y = 0; y < numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y + 1),
                            distance: Math.sqrt(2 * restDistance * restDistance),
                            type: 'shear'
                        });
                        
                        this.constraints.push({
                            p1: this.getPoint(x + 1, y),
                            p2: this.getPoint(x, y + 1),
                            distance: Math.sqrt(2 * restDistance * restDistance),
                            type: 'shear'
                        });
                    }
                }
            }

            update(dt, wind) {
                const GRAVITY = GRAVITY_STRENGTH * dt;
                
                // Actualizar tiempo
                time += dt * 0.001;

                // Actualizar puntos
                for (let i = 0; i < this.points.length; i++) {
                    const point = this.points[i];
                    if (!point.pinned) {
                        // Aplicar gravedad
                        point.vy += GRAVITY;
                        
                        // Aplicar viento
                        if (wind && wind.active) {
                            // Calcular efectos de turbulencia natural
                            const noise1 = Math.sin(time * 2 + i * 0.1) * 0.1;
                            const noise2 = Math.cos(time * 3 + i * 0.05) * 0.1;
                            
                            // El viento afecta de manera diferente según la posición
                            const windEffect = wind.strength * point.windFriction;
                            
                            point.addForce(
                                (wind.x + noise1) * windEffect, 
                                (wind.y + noise2) * windEffect
                            );
                            
                            // Añadir efecto de ondulación dependiendo de frecuencias
                            if (wind.frequencies) {
                                const bassEffect = wind.frequencies.bass * 0.001;
                                const midEffect = wind.frequencies.mid * 0.0005;
                                
                                // Usar bajos para crear ondas verticales
                                point.vy += Math.sin(time * 10 + point.x * 0.05) * bassEffect;
                                
                                // Usar medios para ondas horizontales
                                point.vx += Math.cos(time * 8 + point.y * 0.03) * midEffect;
                            }
                        }
                        
                        // Añadir ligera turbulencia ambiental siempre presente
                        const ambientTurbulence = 0.002;
                        const airNoise = Math.sin(time * 2 + i * 0.3) * ambientTurbulence;
                        point.vx += airNoise;
                        
                        // Actualizar posición
                        const prevX = point.x;
                        const prevY = point.y;
                        point.x += point.vx;
                        point.y += point.vy;
                        
                        // Aplicar amortiguación (damping)
                        point.vx = (point.x - prevX) * DAMPING * point.friction;
                        point.vy = (point.y - prevY) * DAMPING * point.friction;
                    }
                }
                
                // Resolver restricciones
                for (let iter = 0; iter < CONSTRAINT_ITERATIONS; iter++) {
                    for (let j = 0; j < this.constraints.length; j++) {
                        const c = this.constraints[j];
                        const p1 = c.p1;
                        const p2 = c.p2;

                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const currentDistance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (currentDistance === 0) continue;
                        
                        // Factor de rigidez según tipo de restricción
                        let stiffness = 1;
                        if (c.type === 'shear') stiffness = 0.7;
                        
                        // Calcular la corrección
                        const diff = (c.distance - currentDistance) / currentDistance * stiffness;

                        // Distribuir corrección según si están fijados
                        const percent1 = p1.pinned ? 0 : 0.5;
                        const percent2 = p2.pinned ? 0 : 0.5;

                        const offsetX = dx * diff;
                        const offsetY = dy * diff;

                        p1.x -= offsetX * percent1;
                        p1.y -= offsetY * percent1;

                        p2.x += offsetX * percent2;
                        p2.y += offsetY * percent2;
                    }
                }
            }

            draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Dibujar la tela
                for (let y = 0; y < numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        const p1 = this.getPoint(x, y);
                        const p2 = this.getPoint(x + 1, y);
                        const p3 = this.getPoint(x + 1, y + 1);
                        const p4 = this.getPoint(x, y + 1);

                        // Calcular centro del cuadrilátero
                        const centerX = (p1.x + p2.x + p3.x + p4.x) / 4;
                        const centerY = (p1.y + p2.y + p3.y + p4.y) / 4;
                        
                        // Vectores para normal
                        const vx1 = p2.x - p1.x;
                        const vy1 = p2.y - p1.y;
                        const vx2 = p4.x - p1.x;
                        const vy2 = p4.y - p1.y;
                        
                        // Cálculo simplificado de normal (tomando producto cruz en 2D)
                        const normalZ = vx1 * vy2 - vy1 * vx2;
                        
                        // Dirección de luz principal (desde arriba/izquierda)
                        const lightDir = normalZ > 0 ? 1 : -1;
                        
                        // Factor de iluminación simplificado
                        const lightIntensity = Math.abs(normalZ) / (clothWidth / 8) * lightDir;
                        const brightness = 200 + lightIntensity * 40;
                        
                        // Dibujar el cuadrilátero
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.lineTo(p3.x, p3.y);
                        ctx.lineTo(p4.x, p4.y);
                        ctx.closePath();
                        
                        // Crear gradiente para simular pliegues y textura
                        try {
                            const gradient = ctx.createRadialGradient(
                                centerX, centerY, 0,
                                centerX, centerY, restDistance
                            );
                            
                            const r = Math.max(100, Math.min(255, brightness));
                            const g = Math.max(100, Math.min(255, brightness));
                            const b = Math.max(120, Math.min(255, brightness + 10));
                            
                            gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.97)`);
                            gradient.addColorStop(1, `rgba(${r-20}, ${g-20}, ${b-10}, 0.95)`);
                            
                            ctx.fillStyle = gradient;
                            ctx.fill();
                        } catch (e) {
                            // Fallback simple
                            ctx.fillStyle = `rgba(240, 240, 255, 0.95)`;
                            ctx.fill();
                        }
                        
                        // Trazar bordes sutiles
                        ctx.strokeStyle = `rgba(200, 200, 220, 0.1)`;
                        ctx.lineWidth = 0.3;
                        ctx.stroke();
                    }
                }
                
                // Primera vez que se renderiza, añadir efecto de "despliegue"
                if (isFirstRender) {
                    isFirstRender = false;
                    this.unfold();
                }
            }
            
            // Método para desplegar la tela de forma natural
            unfold() {
                for (let i = 0; i < this.points.length; i++) {
                    const point = this.points[i];
                    if (!point.pinned) {
                        // Añadir fuerza para desplegar
                        point.vy += 0.5;
                    }
                }
            }
        }

        const cloth = new Cloth();

        // Lógica de micrófono y análisis de audio mejorado
        let wind = {
            x: 0,
            y: 0,
            strength: 0,
            active: false,
            frequencies: {
                bass: 0,
                mid: 0,
                high: 0
            }
        };
        let audioContext;
        let analyser;
        let dataArray;
        
        // Array para histórico de valores de audio (para suavizado)
        let audioHistory = [];
        const historySize = 5;

        async function iniciarMicrofono() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: true
                });
                audioContext = new(window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512; // Mayor resolución espectral
                analyser.smoothingTimeConstant = 0.8; // Suavizado para evitar saltos bruscos
                
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                analizarAudio();
                
                feedback.textContent = "Micrófono activado - Habla o haz sonidos para interactuar con la tela";
            } catch (err) {
                console.error("Error al iniciar el micrófono:", err);
                feedback.textContent = "Error al acceder al micrófono";
            }
        }

        function analizarAudio() {
            if (!analyser) return;
            
            analyser.getByteFrequencyData(dataArray);
            
            // Dividir el espectro en bandas de frecuencia
            const length = dataArray.length;
            const bassRange = Math.floor(length * 0.1);      // 0-10% - Bajos
            const midRange = Math.floor(length * 0.5);       // 10-50% - Medios
            const highRange = length - bassRange - midRange; // 50-100% - Altos
            
            // Calcular energía en cada banda
            let bassSum = 0;
            let midSum = 0;
            let highSum = 0;
            
            // Bajos (0-200Hz aprox)
            for (let i = 0; i < bassRange; i++) {
                bassSum += dataArray[i];
            }
            
            // Medios (200-2000Hz aprox)
            for (let i = bassRange; i < bassRange + midRange; i++) {
                midSum += dataArray[i];
            }
            
            // Altos (2000-20000Hz aprox)
            for (let i = bassRange + midRange; i < length; i++) {
                highSum += dataArray[i];
            }
            
            // Normalizar valores
            const bassAvg = bassSum / bassRange;
            const midAvg = midSum / midRange;
            const highAvg = highSum / highRange;
            
            // Añadir a histórico para suavizado
            audioHistory.push({
                bass: bassAvg,
                mid: midAvg,
                high: highAvg
            });
            
            // Mantener tamaño de histórico
            if (audioHistory.length > historySize) {
                audioHistory.shift();
            }
            
            // Calcular promedio suavizado
            let smoothBass = 0;
            let smoothMid = 0;
            let smoothHigh = 0;
            
            for (let i = 0; i < audioHistory.length; i++) {
                smoothBass += audioHistory[i].bass;
                smoothMid += audioHistory[i].mid;
                smoothHigh += audioHistory[i].high;
            }
            
            smoothBass /= audioHistory.length;
            smoothMid /= audioHistory.length;
            smoothHigh /= audioHistory.length;
            
            // Umbral dinámico basado en historial
            const umbral = 35;
            
            // Actualizar viento basado en análisis de frecuencias
            if (smoothBass > umbral || smoothMid > umbral) {
                // Diferentes frecuencias afectan de manera distinta
                const bassForce = Math.max(0, (smoothBass - umbral) / 40);
                const midForce = Math.max(0, (smoothMid - umbral) / 60);
                const highForce = Math.max(0, (smoothHigh - umbral) / 80);
                
                // Intensidad total influenciada por todas las bandas
                wind.strength = Math.min(bassForce * 1.5 + midForce + highForce * 0.5, 4);
                
                // Dirección más dinámica según las frecuencias
                wind.x = 0.3 + (bassForce * 0.3);
                wind.y = 0.1 + (midForce * 0.2);
                
                // Guardar frecuencias para efectos adicionales
                wind.frequencies = {
                    bass: bassForce * 100,
                    mid: midForce * 100,
                    high: highForce * 100
                };
                
                wind.active = true;
            } else {
                // Reducción suave del viento cuando no hay sonido
                wind.strength *= 0.95;
                
                if (wind.strength < 0.05) {
                    wind.active = false;
                    wind.strength = 0;
                }
                
                // Mantener frecuencias pero reducirlas gradualmente
                if (wind.frequencies) {
                    wind.frequencies.bass *= 0.95;
                    wind.frequencies.mid *= 0.95;
                    wind.frequencies.high *= 0.95;
                }
            }
            
            // Actualizar retroalimentación visual
            if (wind.active) {
                feedback.textContent = `Interactuando: Intensidad ${Math.round(wind.strength*100)/100} - Bajos: ${Math.round(smoothBass)} - Medios: ${Math.round(smoothMid)}`;
            } else {
                feedback.textContent = "Micrófono activo - Habla o haz sonidos para interactuar";
            }
            
            requestAnimationFrame(analizarAudio);
        }

        function animate() {
            cloth.update(16, wind);
            cloth.draw();
            requestAnimationFrame(animate);
        }

        // Iniciar al hacer clic en el botón
        startButton.addEventListener('click', () => {
            startButton.style.display = 'none';
            iniciarMicrofono();
            animate();
        });
        
        // Ajustar tamaño del canvas al redimensionar la ventana
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>

</html>

