<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Casa Globo Interactiva</title>
<style>
  body {
    margin: 0; padding: 0; overflow: hidden;
    background-color: #000;
    display: flex; justify-content: center; align-items: center;
    height: 100vh;
    touch-action: none;
  }
  #canvas-container {
    position: relative;
    width: 800px; height: 600px;
  }
  canvas {
    border: 1px solid #333;
    background-color: #000;
    box-shadow: 0 0 15px rgba(255,255,255,0.1);
    cursor: pointer;
    display: block;
    width: 100%;
    height: 100%;
  }
  /* Ocultar textos y botones */
  #restart, #mic-status, #instructions {
    display: none !important;
  }
</style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="canvas" width="800" height="600"></canvas>
    <button id="restart">Reiniciar</button>
    <div id="mic-status">Micrófono: Desactivado</div>
    <div id="instructions">Instrucciones aquí</div>
  </div>
  <audio id="pop-sound" src="reventar.mp3" preload="auto"></audio>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const popSound = document.getElementById('pop-sound');

  const casaState = {
    inflada: true,
    rota: false,
    puntos: [],
    puntosCostra: [],
    fragments: [],
    dragging: false,
    dragIndex: -1,
    dragFragment: null,
    lastX: 0,
    lastY: 0,
    inflation: 0,       // 0..3 máximo
    opacidad: 1,
    elasticidad: 0.05,
    tensionMax: 150,
    brillo: 0,
    bordeColor: '#8B4513',
    cursorDistancia: 0,
    cursorInteraccion: false,
    fragmentsSnapped: 0,
    reconstruccionIniciada: false,
    bouncePhase: 0,
    bounceIntensity: 0,
    isBouncingActive: false,
    devicePixelRatio: window.devicePixelRatio || 1,
  };

  function setupCanvas() {
    const containerWidth = canvas.parentElement.clientWidth;
    const containerHeight = canvas.parentElement.clientHeight;
    canvas.style.width = containerWidth + 'px';
    canvas.style.height = containerHeight + 'px';
    canvas.width = containerWidth * casaState.devicePixelRatio;
    canvas.height = containerHeight * casaState.devicePixelRatio;
    ctx.scale(casaState.devicePixelRatio, casaState.devicePixelRatio);
  }

  function initHouse() {
    const centerX = canvas.width / (2 * casaState.devicePixelRatio);
    const centerY = canvas.height / (2 * casaState.devicePixelRatio);
    const baseWidth = Math.min(canvas.width / casaState.devicePixelRatio, 800) * 0.25;
    const baseHeight = Math.min(canvas.height / casaState.devicePixelRatio, 600) * 0.35;

    casaState.puntos = [
      {x: centerX - baseWidth, y: centerY + baseHeight, origX: centerX - baseWidth, origY: centerY + baseHeight},
      {x: centerX - baseWidth, y: centerY, origX: centerX - baseWidth, origY: centerY},
      {x: centerX - baseWidth, y: centerY - baseHeight, origX: centerX - baseWidth, origY: centerY - baseHeight},
      {x: centerX - baseWidth/2, y: centerY - baseHeight*1.25, origX: centerX - baseWidth/2, origY: centerY - baseHeight*1.25},
      {x: centerX, y: centerY - baseHeight*1.5, origX: centerX, origY: centerY - baseHeight*1.5},
      {x: centerX + baseWidth/2, y: centerY - baseHeight*1.25, origX: centerX + baseWidth/2, origY: centerY - baseHeight*1.25},
      {x: centerX + baseWidth, y: centerY - baseHeight, origX: centerX + baseWidth, origY: centerY - baseHeight},
      {x: centerX + baseWidth, y: centerY, origX: centerX + baseWidth, origY: centerY},
      {x: centerX + baseWidth, y: centerY + baseHeight, origX: centerX + baseWidth, origY: centerY + baseHeight},
      {x: centerX - baseWidth, y: centerY + baseHeight, origX: centerX - baseWidth, origY: centerY + baseHeight}
    ];

    casaState.puntosCostra = [];
    for (let i = 0; i < casaState.puntos.length - 1; i++) {
      const p1 = casaState.puntos[i];
      const p2 = casaState.puntos[i + 1];
      const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      const numPuntos = Math.max(5, Math.floor(dist / 10));
      for (let j = 0; j < numPuntos; j++) {
        const t = j / numPuntos;
        const x = p1.x + (p2.x - p1.x) * t;
        const y = p1.y + (p2.y - p1.y) * t;
        const variacion = 2;
        const offsetX = (Math.random() - 0.5) * variacion;
        const offsetY = (Math.random() - 0.5) * variacion;
        casaState.puntosCostra.push({
          x: x + offsetX,
          y: y + offsetY,
          size: 1 + Math.random() * 1.5
        });
      }
    }

    casaState.inflation = 0;
    casaState.opacidad = 1;
    casaState.brillo = 0;
    casaState.rota = false;
    casaState.fragments = [];
    casaState.fragmentsSnapped = 0;
    casaState.reconstruccionIniciada = false;
    casaState.bounceIntensity = 0;
    casaState.isBouncingActive = false;
  }

  function inflarCasa() {
    const centerX = canvas.width / (2 * casaState.devicePixelRatio);
    const centerY = canvas.height / (2 * casaState.devicePixelRatio);
    for (let i = 0; i < casaState.puntos.length; i++) {
      const p = casaState.puntos[i];
      // Factor aumentado para inflar mucho más
      p.x = p.origX + (p.origX - centerX) * casaState.inflation * 0.5;
      p.y = p.origY + (p.origY - centerY) * casaState.inflation * 0.5;
    }
  }

  function drawGrid(context, points, centerX, centerY, scale = 1) {
    context.save();

    // Clip para limitar cuadrícula dentro de la casa
    context.beginPath();
    points.forEach((p, i) => {
      if (i === 0) context.moveTo(p.x, p.y);
      else context.lineTo(p.x, p.y);
    });
    context.closePath();
    context.clip();

    const distortion = 1 + casaState.inflation * 0.8;
    context.strokeStyle = `rgba(255, 255, 255, ${0.1 + casaState.brillo * 0.2})`;
    context.lineWidth = 0.5;

    const gridSize = 10 * scale;
    const gridRange = 150 * scale;

    let bounceEffect = 0;
    if (casaState.isBouncingActive) {
      bounceEffect = Math.sin(casaState.bouncePhase) * casaState.bounceIntensity;
    }

    // Líneas horizontales
    for (let i = -gridRange; i <= gridRange; i += gridSize) {
      context.beginPath();
      for (let x = -gridRange; x <= gridRange; x += 5) {
        const normalizedX = x / gridRange;
        const normalizedY = i / gridRange;
        const distToCenter = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
        const distortionFactor = Math.max(0, 1 - distToCenter) * casaState.inflation;
        const xPos = centerX + x;
        const amplitude = casaState.inflation * 15 * Math.sin(Math.PI * normalizedY);
        const yPos = centerY + i + amplitude * distortion + bounceEffect;
        if (x === -gridRange) context.moveTo(xPos, yPos);
        else context.lineTo(xPos, yPos);
      }
      context.stroke();
    }

    // Líneas verticales
    for (let i = -gridRange; i <= gridRange; i += gridSize) {
      context.beginPath();
      for (let y = -gridRange; y <= gridRange; y += 5) {
        const normalizedX = i / gridRange;
        const normalizedY = y / gridRange;
        const distToCenter = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
        const distortionFactor = Math.max(0, 1 - distToCenter) * casaState.inflation;
        const yPos = centerY + y;
        const amplitude = casaState.inflation * 15 * Math.sin(Math.PI * normalizedX);
        const xPos = centerX + i + amplitude * distortionFactor + bounceEffect;
        if (y === -gridRange) context.moveTo(xPos, yPos);
        else context.lineTo(xPos, yPos);
      }
      context.stroke();
    }

    context.restore();
  }

  function drawStitches(context, points, isFragment = false) {
    context.save();
    if (isFragment) {
      context.lineWidth = 1.5;
      context.strokeStyle = casaState.bordeColor;
      context.beginPath();
      for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i];
        const p2 = points[i + 1];
        const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const numPuntos = Math.max(3, Math.floor(dist / 5));
        for (let j = 0; j < numPuntos; j++) {
          const t1 = j / numPuntos;
          const t2 = (j + 0.5) / numPuntos;
          const x1 = p1.x + (p2.x - p1.x) * t1;
          const y1 = p1.y + (p2.y - p1.y) * t1;
          const x2 = p1.x + (p2.x - p1.x) * t2;
          const y2 = p1.y + (p2.y - p1.y) * t2;
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy);
          if (len > 0) {
            const perpX = -dy / len * 2;
            const perpY = dx / len * 2;
            const dir = j % 2 === 0 ? 1 : -1;
            context.moveTo(x1, y1);
            context.lineTo(x2 + perpX * dir, y2 + perpY * dir);
          }
        }
      }
      context.stroke();
    } else {
      for (let i = 0; i < casaState.puntosCostra.length; i++) {
        const punto = casaState.puntosCostra[i];
        const size = punto.size * (1 + casaState.inflation * 0.2);
        context.lineWidth = 1.5;
        context.strokeStyle = casaState.bordeColor;
        context.beginPath();
        context.moveTo(punto.x - size, punto.y - size);
        context.lineTo(punto.x + size, punto.y + size);
        context.stroke();
        context.beginPath();
        context.moveTo(punto.x + size, punto.y - size);
        context.lineTo(punto.x - size, punto.y + size);
        context.stroke();
      }
    }
    context.restore();
  }

  function checkTension() {
    if (casaState.inflation > 0.3) {
      const tension = casaState.inflation * 150;
      if (tension > casaState.tensionMax) {
        casaState.rota = true;
        popSound.play();
      }
    }
  }

  function drawHouse() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!casaState.rota) {
      inflarCasa();
      drawGrid(ctx, casaState.puntos, canvas.width / (2 * casaState.devicePixelRatio), canvas.height / (2 * casaState.devicePixelRatio), 1);
      // Dibuja la casa con bordes suaves
      ctx.beginPath();
      const pts = casaState.puntos;
      for (let i = 0; i < pts.length - 1; i++) {
        if (i === 0) ctx.moveTo(pts[i].x, pts[i].y);
        const midX = (pts[i].x + pts[i + 1].x) / 2;
        const midY = (pts[i].y + pts[i + 1].y) / 2;
        ctx.quadraticCurveTo(pts[i].x, pts[i].y, midX, midY);
      }
      ctx.closePath();
      const gradient = ctx.createRadialGradient(canvas.width / (2 * casaState.devicePixelRatio), canvas.height / (2 * casaState.devicePixelRatio), 50, canvas.width / (2 * casaState.devicePixelRatio), canvas.height / (2 * casaState.devicePixelRatio), 200);
      gradient.addColorStop(0, `rgba(255,255,255,${0.6 + casaState.brillo * 0.4})`);
      gradient.addColorStop(1, `rgba(180,180,220,0.8)`);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.strokeStyle = casaState.bordeColor;
      ctx.lineWidth = 3;
      ctx.stroke();
      drawStitches(ctx, null, false);
    } else {
      // Aquí dibuja fragmentos si la casa está rota (puedes mantener tu código original)
    }
  }

  function update() {
    if (!casaState.rota) {
      if (casaState.inflation < 1) {
        casaState.inflation += 0.005; // Simulación de inflado progresivo
      }
      casaState.brillo = casaState.inflation;
      checkTension();
    }
  }

  function loop() {
    update();
    drawHouse();
    requestAnimationFrame(loop);
  }

  // Inicialización
  setupCanvas();
  initHouse();
  loop();

  // Aquí puedes agregar la lógica para controlar inflation vía micrófono o eventos

</script>
</body>
</html>
