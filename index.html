<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Casa Globo Interactiva Mejorada</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <audio id="pop-sound" src="reventar.mp3" preload="auto"></audio>

    <script>
        // Variables globales
        let audioContext;
        let analyser;
        let microphone;
        let javascriptNode;
        let audioInitialized = false;
        
        // Estado de la casa
        let casaState = {
            inflada: true,
            rota: false,
            puntos: [],         // Puntos del borde de la casa
            fragments: [],      // Fragmentos después de reventar
            dragging: false,
            dragIndex: -1,
            dragFragment: null, // Para arrastrar fragmentos
            lastX: 0,
            lastY: 0,
            inflation: 0,       // Nivel de inflado (0-1)
            opacidad: 1,        // Opacidad de la tela (inversa a inflado)
            elasticidad: 0.05,  // Qué tan rápido regresa a su forma
            tensionMax: 75,     // Tensión máxima antes de reventar - AUMENTADO para más resistencia
            brillo: 0,          // Nivel de brillo del látex
            bordeColor: '#8B4513', // Color café para el bordado
            cursorDistancia: 0, // Distancia del cursor a la casa
            cursorInteraccion: false, // Si el cursor está interactuando con la casa
            inflationFactor: 0.8, // Factor de inflación por audio - REDUCIDO para inflado más controlado
            mouseInflationFactor: 0.001, // Factor de inflación por mouse/touch - MINIMIZADO
            cursorX: 0,
            cursorY: 0,
            lastInteractionTime: 0,
            interactionCount: 0, // Contador de interacciones para reventar por interacción excesiva
            audioVolume: 0,     // Volumen actual del audio para visualización
            maxAudioAmplitude: 0, // Máxima amplitud de audio registrada
            tensionPorToque: 0, // Nivel de tensión acumulada por toques
            touchThreshold: 200 // Umbral de tensión para reventar por interacción
        };
        
        // Referencias a elementos del DOM
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const popSound = document.getElementById('pop-sound');
        
        // Ajustar el tamaño del canvas al tamaño de la ventana
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // Inicializar la forma de la casa con puntos de bordado
        function initHouse() {
            // Ajustar el canvas al tamaño de la ventana
            resizeCanvas();
            
            // Calcular centro relativo al canvas actual
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / 800; // Factor de escala basado en 800px
            
            // Contorno de la casa con bordes más redondeados, centrado en el canvas
            casaState.puntos = [
                {x: centerX - 100 * scale, y: centerY + 150 * scale, origX: centerX - 100 * scale, origY: centerY + 150 * scale},
                {x: centerX - 100 * scale, y: centerY + 50 * scale, origX: centerX - 100 * scale, origY: centerY + 50 * scale},
                {x: centerX - 100 * scale, y: centerY - 50 * scale, origX: centerX - 100 * scale, origY: centerY - 50 * scale},
                {x: centerX - 50 * scale, y: centerY - 100 * scale, origX: centerX - 50 * scale, origY: centerY - 100 * scale},
                {x: centerX, y: centerY - 150 * scale, origX: centerX, origY: centerY - 150 * scale},
                {x: centerX + 50 * scale, y: centerY - 100 * scale, origX: centerX + 50 * scale, origY: centerY - 100 * scale},
                {x: centerX + 100 * scale, y: centerY - 50 * scale, origX: centerX + 100 * scale, origY: centerY - 50 * scale},
                {x: centerX + 100 * scale, y: centerY + 50 * scale, origX: centerX + 100 * scale, origY: centerY + 50 * scale},
                {x: centerX + 100 * scale, y: centerY + 150 * scale, origX: centerX + 100 * scale, origY: centerY + 150 * scale},
                {x: centerX - 100 * scale, y: centerY + 150 * scale, origX: centerX - 100 * scale, origY: centerY + 150 * scale}
            ];
            
            // Añadir puntos de bordado/costura a lo largo del contorno
            casaState.puntosCostra = [];
            for (let i = 0; i < casaState.puntos.length - 1; i++) {
                const p1 = casaState.puntos[i];
                const p2 = casaState.puntos[i + 1];
                const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                const numPuntos = Math.max(5, Math.floor(dist / (10 * scale))); // Un punto cada 10px aprox, ajustado por escala
                
                for (let j = 0; j < numPuntos; j++) {
                    const t = j / numPuntos;
                    const x = p1.x + (p2.x - p1.x) * t;
                    const y = p1.y + (p2.y - p1.y) * t;
                    
                    // Añadir pequeña variación aleatoria para dar aspecto más natural
                    const variacion = 2 * scale;
                    const offsetX = (Math.random() - 0.5) * variacion;
                    const offsetY = (Math.random() - 0.5) * variacion;
                    
                    casaState.puntosCostra.push({
                        x: x + offsetX,
                        y: y + offsetY,
                        size: (1 + Math.random() * 1.5) * scale // Tamaño variable, escalado
                    });
                }
            }
            
            casaState.inflation = 0;
            casaState.opacidad = 1;
            casaState.brillo = 0;
            casaState.rota = false;
            casaState.fragments = [];
            casaState.interactionCount = 0;
            casaState.audioVolume = 0;
            casaState.maxAudioAmplitude = 0;
            casaState.tensionPorToque = 0;
        }
        
        // Comprobar si un punto está dentro del contorno de la casa
        function isPointInHouse(x, y) {
            let inside = false;
            let j = casaState.puntos.length - 1;
            
            for (let i = 0; i < casaState.puntos.length; i++) {
                const xi = casaState.puntos[i].x;
                const yi = casaState.puntos[i].y;
                const xj = casaState.puntos[j].x;
                const yj = casaState.puntos[j].y;
                
                const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
                j = i;
            }
            
            return inside;
        }
        
        // Dibujar cuadrícula en la superficie para dar efecto de látex (solo dentro de la casa)
        function drawGrid(context) {
            context.save();
            
            // Calcular centro de la casa
            let centerX = 0, centerY = 0;
            for (let i = 0; i < casaState.puntos.length - 1; i++) {
                centerX += casaState.puntos[i].x;
                centerY += casaState.puntos[i].y;
            }
            centerX /= (casaState.puntos.length - 1);
            centerY /= (casaState.puntos.length - 1);
            
            // Calcular el tamaño aproximado de la casa para escalar la cuadrícula
            let maxDist = 0;
            for (let i = 0; i < casaState.puntos.length - 1; i++) {
                const dx = casaState.puntos[i].x - centerX;
                const dy = casaState.puntos[i].y - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                maxDist = Math.max(maxDist, dist);
            }
            
            // Color base de la cuadrícula basado en inflación
            const opacidadBase = 0.1 + casaState.brillo * 0.3;
            
            // Cambiar color de la cuadrícula según nivel de inflación (rojo cuando está a punto de reventar)
            const inflationRatio = casaState.inflation / 1.0;
            const rojoBrillo = Math.min(255, 200 + inflationRatio * 55);
            const verdeBrillo = Math.max(100, 255 - inflationRatio * 155);
            const azulBrillo = Math.max(100, 255 - inflationRatio * 155);
            
            context.strokeStyle = `rgba(${rojoBrillo}, ${verdeBrillo}, ${azulBrillo}, ${opacidadBase})`;
            context.lineWidth = 0.5;
            
            // Aplicar recorte al path de la casa para que la cuadrícula solo se dibuje dentro
            context.beginPath();
            casaState.puntos.forEach((punto, i) => {
                if (i === 0) {
                    context.moveTo(punto.x, punto.y);
                } else {
                    context.lineTo(punto.x, punto.y);
                }
            });
            context.closePath();
            context.clip();
            
            // Dibujar líneas horizontales y verticales
            const scale = Math.min(canvas.width, canvas.height) / 800;
            const gridSize = 10 * scale;
            const gridRange = maxDist * 1.5; // Extender el rango para asegurarnos que cubre toda la casa
            
            for (let i = -gridRange; i <= gridRange; i += gridSize) {
                // Líneas horizontales curvadas según inflación (más curvatura con más inflación)
                context.beginPath();
                context.moveTo(centerX - gridRange, centerY + i);
                context.bezierCurveTo(
                    centerX - gridRange/2, centerY + i * (1 + casaState.inflation * 0.5),
                    centerX + gridRange/2, centerY + i * (1 + casaState.inflation * 0.5),
                    centerX + gridRange, centerY + i
                );
                context.stroke();
                
                // Líneas verticales curvadas según inflación
                context.beginPath();
                context.moveTo(centerX + i, centerY - gridRange);
                context.bezierCurveTo(
                    centerX + i * (1 + casaState.inflation * 0.5), centerY - gridRange/2,
                    centerX + i * (1 + casaState.inflation * 0.5), centerY + gridRange/2,
                    centerX + i, centerY + gridRange
                );
                context.stroke();
            }
            
            context.restore();
        }
        
        // Dibujar puntadas de bordado realistas
        function drawStitches(context, points, isFragment = false) {
            context.save();
            
            // Configuración para las puntadas
            if (isFragment) {
                // Para fragmentos, ajustar el dibujo de las puntadas
                context.lineWidth = 1.5;
                context.strokeStyle = casaState.bordeColor;
                
                // Dibujar las puntadas como pequeños segmentos inclinados en zigzag
                context.beginPath();
                
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    const numPuntos = Math.max(3, Math.floor(dist / 5));
                    
                    for (let j = 0; j < numPuntos; j++) {
                        const t1 = j / numPuntos;
                        const t2 = (j + 0.5) / numPuntos;
                        
                        const x1 = p1.x + (p2.x - p1.x) * t1;
                        const y1 = p1.y + (p2.y - p1.y) * t1;
                        
                        const x2 = p1.x + (p2.x - p1.x) * t2;
                        const y2 = p1.y + (p2.y - p1.y) * t2;
                        
                        // Desplazamiento perpendicular para el zigzag
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        
                        if (len > 0) {
                            const perpX = -dy / len * 2;
                            const perpY = dx / len * 2;
                            
                            // Alternar la dirección para zigzag
                            const dir = j % 2 === 0 ? 1 : -1;
                            
                            context.moveTo(x1, y1);
                            context.lineTo(x2 + perpX * dir, y2 + perpY * dir);
                        }
                    }
                }
                
                context.stroke();
            } else {
                // Para la casa completa, dibujar puntadas individuales en los puntos predefinidos
                for (let i = 0; i < casaState.puntosCostra.length; i++) {
                    const punto = casaState.puntosCostra[i];
                    const size = punto.size * (1 + casaState.inflation * 0.3);
                    
                    // Dibujar el punto con un estilo de puntada cruzada
                    context.lineWidth = 1.5;
                    context.strokeStyle = casaState.bordeColor;
                    
                    context.beginPath();
                    context.moveTo(punto.x - size, punto.y - size);
                    context.lineTo(punto.x + size, punto.y + size);
                    context.stroke();
                    
                    context.beginPath();
                    context.moveTo(punto.x + size, punto.y - size);
                    context.lineTo(punto.x - size, punto.y + size);
                    context.stroke();
                }
            }
            
            context.restore();
        }
        
        // Dibujar indicador visual de volumen del audio
        function drawAudioIndicator(context) {
            if (!audioInitialized) return;
            
            // Calcular centro de la casa
            let centerX = 0, centerY = 0;
            for (let i = 0; i < casaState.puntos.length - 1; i++) {
                centerX += casaState.puntos[i].x;
                centerY += casaState.puntos[i].y;
            }
            centerX /= (casaState.puntos.length - 1);
            centerY /= (casaState.puntos.length - 1);
            
            const audioLevel = casaState.audioVolume;
            if (audioLevel > 0.05) {
                context.save();
                
                // Crear un halo alrededor de la casa que pulsa con el audio
                const pulseRadius = 10 + audioLevel * 100;
                const pulseGradient = context.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, pulseRadius
                );
                
                // Color basado en intensidad del audio
                const audioIntensity = Math.min(1, audioLevel);
                const redValue = Math.floor(200 + audioIntensity * 55);
                const greenValue = Math.floor(200 - audioIntensity * 100);
                const blueValue = Math.floor(255 - audioIntensity * 100);
                
                pulseGradient.addColorStop(0, `rgba(${redValue}, ${greenValue}, ${blueValue}, ${0.3 * audioIntensity})`);
                pulseGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                context.fillStyle = pulseGradient;
                context.beginPath();
                context.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
                context.fill();
                
                context.restore();
            }
        }
        
        // Dibujar la casa según su estado actual
        function drawHouse() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (casaState.rota) {
                // Dibujar los fragmentos de la casa rota
                casaState.fragments.forEach(fragment => {
                    ctx.save();
                    ctx.translate(fragment.x, fragment.y);
                    ctx.rotate(fragment.rotation);
                    
                    // Dibujar el fragmento
                    ctx.beginPath();
                    fragment.points.forEach((point, i) => {
                        if (i === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.closePath();
                    
                    // Efecto de brillo para látex mejorado
                    const gradientFill = ctx.createRadialGradient(0, 0, 5, 0, 0, 50);
                    
                    // Colores más realistas para el látex
                    gradientFill.addColorStop(0, `rgba(255, 255, 255, ${0.9 - fragment.transparency})`);
                    gradientFill.addColorStop(0.3, `rgba(240, 240, 255, ${0.8 - fragment.transparency})`);
                    gradientFill.addColorStop(0.6, `rgba(230, 230, 250, ${0.7 - fragment.transparency})`);
                    gradientFill.addColorStop(0.8, `rgba(220, 220, 245, ${0.6 - fragment.transparency})`);
                    gradientFill.addColorStop(1, `rgba(200, 200, 240, ${0.5 - fragment.transparency})`);
                    
                    ctx.fillStyle = gradientFill;
                    ctx.fill();
                    
                    // Dibujar el contorno del fragmento (muy sutil)
                    ctx.strokeStyle = 'rgba(200, 200, 230, 0.4)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                    
                    // Dibujar el bordado con realismo
                    drawStitches(ctx, fragment.points, true);
                    
                    ctx.restore();
                });
            } else {
                // Dibujar el indicador de audio antes de la casa
                drawAudioIndicator(ctx);
                
                // Dibujar la casa inflada con efecto redondeado y brillante
                ctx.beginPath();
                
                // Dibujar la casa con curvas Bezier para bordes más redondeados
                ctx.moveTo(casaState.puntos[0].x, casaState.puntos[0].y);
                
                // Calcular centro para efectos
                let centerX = 0, centerY = 0;
                for (let i = 0; i < casaState.puntos.length - 1; i++) {
                    centerX += casaState.puntos[i].x;
                    centerY += casaState.puntos[i].y;
                }
                centerX /= (casaState.puntos.length - 1);
                centerY /= (casaState.puntos.length - 1);
                
                for (let i = 0; i < casaState.puntos.length - 1; i++) {
                    const current = casaState.puntos[i];
                    const next = casaState.puntos[i + 1];
                    
                    if (i === 0 || i === casaState.puntos.length - 2) {
                        // Para el primer y último segmento, usamos línea recta
                        ctx.lineTo(next.x, next.y);
                    } else {
                        // Para los demás segmentos, usamos curvas
                        const cp1x = current.x + (next.x - current.x) / 3;
                        const cp1y = current.y + (next.y - current.y) / 3;
                        const cp2x = current.x + 2 * (next.x - current.x) / 3;
                        const cp2y = current.y + 2 * (next.y - current.y) / 3;
                        
                        // Ajustar los puntos de control según la inflación
                        const inflateFactor = 1 + casaState.inflation * 0.8; // Aumentado para que se infle más visiblemente
                        const midX = (current.x + next.x) / 2;
                        const midY = (current.y + next.y) / 2;
                        
                        // Dirección desde el centro hacia el punto medio
                        const dx = midX - centerX;
                        const dy = midY - centerY;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        
                        // Ajustar puntos de control para curvar hacia afuera
                        if (len > 0) {
                            const inflateX = dx / len * casaState.inflation * 80; // AUMENTADO para inflar más dramáticamente
                            const inflateY = dy / len * casaState.inflation * 80; // AUMENTADO para inflar más dramáticamente
                            
                            ctx.bezierCurveTo(
                                cp1x + inflateX, cp1y + inflateY,
                                cp2x + inflateX, cp2y + inflateY,
                                next.x, next.y
                            );
                        } else {
                            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
                        }
                    }
                }
                
                ctx.closePath();
                
                // Cálculo de radio para efectos
                let maxRadius = 0;
                for (let i = 0; i < casaState.puntos.length - 1; i++) {
                    const dx = casaState.puntos[i].x - centerX;
                    const dy = casaState.puntos[i].y - centerY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    maxRadius = Math.max(maxRadius, dist);
                }
                const radius = maxRadius + casaState.inflation * (maxRadius * 0.8); // AUMENTADO para mayor efecto
                
                // Efecto de brillo para el látex con degradado mejorado
                const gradient = ctx.createRadialGradient(
                    centerX - maxRadius * 0.2, centerY - maxRadius * 0.2, radius * 0.2,
                    centerX, centerY, radius * 1.2
                );
                
                // Ajustar colores según nivel de inflado para efecto más realista
                const inflationRatio = casaState.inflation / 1.0;
                const rojoBase = Math.min(255, 220 + inflationRatio * 35);
                const verdeBase = Math.max(200, 250 - inflationRatio * 50);
                const azulBase = Math.max(200, 250 - inflationRatio * 50);
                
                // Simulación de translucidez del látex
                gradient.addColorStop(0, `rgba(${rojoBase}, ${verdeBase}, ${azulBase}, ${0.9 + casaState.brillo * 0.1})`);
                gradient.addColorStop(0.3, `rgba(${rojoBase-5}, ${verdeBase-5}, ${azulBase+5}, ${0.85 + casaState.brillo * 0.15})`);
                gradient.addColorStop(0.5, `rgba(${rojoBase-10}, ${verdeBase-10}, ${azulBase+10}, ${0.8 + casaState.brillo * 0.2})`);
                gradient.addColorStop(0.7, `rgba(${rojoBase-15}, ${verdeBase-15}, ${azulBase+5}, ${0.75 + casaState.brillo * 0.15})`);
                gradient.addColorStop(0.9, `rgba(${rojoBase-20}, ${verdeBase-20}, ${azulBase}, ${0.7})`);
                gradient.addColorStop(1, `rgba(${rojoBase-25}, ${verdeBase-25}, ${azulBase-5}, ${0.65})`);
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Dibujar el contorno (muy sutil)
                ctx.strokeStyle = 'rgba(200, 200, 230, 0.4)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
                
                // Dibujar cuadrícula para efecto de látex (solo dentro de la casa)
                drawGrid(ctx);
                
                // Dibujar el bordado con puntadas realistas
                drawStitches(ctx, casaState.puntos);
                
                // Añadir brillo especular para efecto de látex
                ctx.beginPath();
                const highlightRadius = maxRadius * 0.3 + casaState.inflation * maxRadius * 0.3; // AUMENTADO para mejor efecto visual
                const highlightGradient = ctx.createRadialGradient(
                    centerX - maxRadius * 0.15, centerY - maxRadius * 0.15, 5,
                    centerX - maxRadius * 0.15, centerY - maxRadius * 0.15, highlightRadius
                );
                highlightGradient.addColorStop(0, `rgba(255, 255, 255, ${0.7 + casaState.brillo * 0.3})`);
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = highlightGradient;
                ctx.arc(centerX - maxRadius * 0.15, centerY - maxRadius * 0.15, highlightRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Mostrar la interacción del cursor
                if (casaState.cursorInteraccion) {
                    // Efecto de distorsión en la dirección del cursor
                    const cursorEffect = 1 - Math.min(1, casaState.cursorDistancia / (maxRadius * 1.5));
                    if (cursorEffect > 0.1) {
                        ctx.beginPath();
                        const pulseRadius = 15 + Math.sin(Date.now() / 200) * 5;
                        const pulseGradient = ctx.createRadialGradient(
                            casaState.cursorX, casaState.cursorY, 1,
                            casaState.cursorX, casaState.cursorY, pulseRadius * (1 + casaState.inflation)
                        );
                        pulseGradient.addColorStop(0, `rgba(255, 220, 220, ${0.6 * cursorEffect})`);
                        pulseGradient.addColorStop(1, 'rgba(255, 200, 200, 0)');
                        
                        ctx.fillStyle = pulseGradient;
                        ctx.arc(casaState.cursorX, casaState.cursorY, pulseRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Indicador visual del nivel de inflado (pequeño brillo que crece con la inflación)
                const inflationIndicatorRadius = maxRadius * 0.1 + casaState.inflation * maxRadius * 0.3; // AUMENTADO para mejor visualización
                ctx.beginPath();
                const indicatorGradient = ctx.createRadialGradient(
                    centerX, centerY, 1,
                    centerX, centerY, inflationIndicatorRadius
                );
                indicatorGradient.addColorStop(0, `rgba(255, ${255 - casaState.inflation * 200}, ${255 - casa /* Continuación desde donde se cortó el código */
State.inflation * 200}, ${255 - casaState.inflation * 200}, ${casaState.inflation * 0.5})`);
                indicatorGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = indicatorGradient;
                ctx.arc(centerX, centerY, inflationIndicatorRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Dibujar datos de depuración
            if (false) { // Cambiar a true para ver datos de depuración
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(10, 10, 250, 130);
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.fillText(`Inflado: ${casaState.inflation.toFixed(2)}`, 20, 30);
                ctx.fillText(`Audio Vol: ${casaState.audioVolume.toFixed(2)}`, 20, 50);
                ctx.fillText(`Max Audio: ${casaState.maxAudioAmplitude.toFixed(2)}`, 20, 70);
                ctx.fillText(`Tensión Toque: ${casaState.tensionPorToque.toFixed(2)}`, 20, 90);
                ctx.fillText(`Interacciones: ${casaState.interactionCount}`, 20, 110);
                ctx.fillText(`Rota: ${casaState.rota}`, 20, 130);
            }
        }
        
        // Función para reventar la casa
        function popHouse(sourceX, sourceY) {
            if (casaState.rota) return;
            
            // Reproducir sonido de pop
            popSound.currentTime = 0;
            popSound.play().catch(e => console.log("Error reproduciendo audio:", e));
            
            // Generar fragmentos desde el punto de ruptura
            casaState.fragments = [];
            
            // Calcular centro para efectos
            let centerX = 0, centerY = 0;
            for (let i = 0; i < casaState.puntos.length - 1; i++) {
                centerX += casaState.puntos[i].x;
                centerY += casaState.puntos[i].y;
            }
            centerX /= (casaState.puntos.length - 1);
            centerY /= (casaState.puntos.length - 1);
            
            // Punto de ruptura (o punto de máxima tensión)
            const burstX = sourceX || centerX;
            const burstY = sourceY || centerY;
            
            // Crear 6 a 10 fragmentos irregulares
            const numFragments = 6 + Math.floor(Math.random() * 5);
            
            // Crear puntos para fragmentación
            const fragPoints = [];
            
            // Hacer una copia profunda de los puntos actuales (inflados)
            casaState.puntos.forEach((p, i) => {
                if (i < casaState.puntos.length - 1) { // Evitar duplicar el último punto
                    fragPoints.push({x: p.x, y: p.y});
                }
            });
            
            // Añadir puntos adicionales para fragmentación más detallada
            const puntosExtra = [];
            for (let i = 0; i < fragPoints.length; i++) {
                const p1 = fragPoints[i];
                const p2 = fragPoints[(i + 1) % fragPoints.length];
                
                // Añadir 2 puntos intermedios
                puntosExtra.push({
                    x: p1.x + (p2.x - p1.x) * 0.33,
                    y: p1.y + (p2.y - p1.y) * 0.33
                });
                
                puntosExtra.push({
                    x: p1.x + (p2.x - p1.x) * 0.66,
                    y: p1.y + (p2.y - p1.y) * 0.66
                });
            }
            
            // Combinar los puntos originales con los extra y ordenarlos por ángulo desde el centro
            fragPoints.push(...puntosExtra);
            
            // Agregar puntos aleatorios dentro de la forma para fragmentación interna
            for (let i = 0; i < 10; i++) {
                // Elegir dos puntos aleatorios del borde
                const idx1 = Math.floor(Math.random() * fragPoints.length);
                const idx2 = Math.floor(Math.random() * fragPoints.length);
                const p1 = fragPoints[idx1];
                const p2 = fragPoints[idx2];
                
                // Interpolar entre ellos con algo de aleatoriedad
                const t = Math.random();
                fragPoints.push({
                    x: p1.x * t + p2.x * (1 - t) + (Math.random() - 0.5) * 20,
                    y: p1.y * t + p2.y * (1 - t) + (Math.random() - 0.5) * 20
                });
            }
            
            // Calcular la línea de ruptura principal (desde el punto de ruptura hacia afuera)
            const burstLines = [];
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI * 2 * i / 6;
                const length = 50 + Math.random() * 100;
                burstLines.push({
                    x1: burstX,
                    y1: burstY,
                    x2: burstX + Math.cos(angle) * length,
                    y2: burstY + Math.sin(angle) * length
                });
            }
            
            // Generar los fragmentos usando triangulación Delaunay (simplificado)
            for (let i = 0; i < numFragments; i++) {
                // Para cada fragmento, elegir un subconjunto aleatorio de puntos
                const fragmentPoints = [];
                const numPoints = 5 + Math.floor(Math.random() * 3);
                
                // Elegir un punto de inicio (cerca del borde preferiblemente)
                const startIdx = Math.floor(Math.random() * fragPoints.length);
                const startPoint = {x: fragPoints[startIdx].x, y: fragPoints[startIdx].y};
                fragmentPoints.push(startPoint);
                
                // Añadir el punto de ruptura para asegurar que es parte de algún fragmento
                if (i === 0) {
                    fragmentPoints.push({x: burstX, y: burstY});
                }
                
                // Encontrar puntos cercanos para formar un fragmento coherente
                for (let j = 0; j < numPoints - 1; j++) {
                    // Elegir un punto con cierta probabilidad según distancia
                    const lastPoint = fragmentPoints[fragmentPoints.length - 1];
                    let bestIdx = -1;
                    let bestDist = Infinity;
                    let bestScore = -Infinity;
                    
                    for (let k = 0; k < fragPoints.length; k++) {
                        const p = fragPoints[k];
                        // Evitar duplicados
                        let isDuplicate = false;
                        for (let l = 0; l < fragmentPoints.length; l++) {
                            if (Math.abs(p.x - fragmentPoints[l].x) < 1 && Math.abs(p.y - fragmentPoints[l].y) < 1) {
                                isDuplicate = true;
                                break;
                            }
                        }
                        
                        if (!isDuplicate) {
                            const dist = Math.sqrt(Math.pow(p.x - lastPoint.x, 2) + Math.pow(p.y - lastPoint.y, 2));
                            const angleFromCenter = Math.atan2(p.y - centerY, p.x - centerX);
                            const angleLastFromCenter = Math.atan2(lastPoint.y - centerY, lastPoint.x - centerX);
                            const angleDiff = Math.abs(angleFromCenter - angleLastFromCenter);
                            
                            // Preferir puntos que estén cercanos pero en dirección radial
                            const score = -dist + (angleDiff < 0.5 ? 30 : 0);
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestIdx = k;
                                bestDist = dist;
                            }
                        }
                    }
                    
                    // Si encontramos un punto válido, añadirlo
                    if (bestIdx >= 0 && bestDist < 150) {
                        fragmentPoints.push({x: fragPoints[bestIdx].x, y: fragPoints[bestIdx].y});
                    }
                }
                
                // Ordenar los puntos por ángulo desde el centroide para garantizar un polígono convexo
                if (fragmentPoints.length >= 3) {
                    // Calcular centroide del fragmento
                    let fcx = 0, fcy = 0;
                    fragmentPoints.forEach(p => {
                        fcx += p.x;
                        fcy += p.y;
                    });
                    fcx /= fragmentPoints.length;
                    fcy /= fragmentPoints.length;
                    
                    // Ordenar por ángulo
                    fragmentPoints.sort((a, b) => {
                        return Math.atan2(a.y - fcy, a.x - fcx) - Math.atan2(b.y - fcy, b.x - fcx);
                    });
                    
                    // Crear la velocidad inicial del fragmento (desde el centro de ruptura)
                    const dirX = fcx - burstX;
                    const dirY = fcy - burstY;
                    const dirLen = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
                    
                    // Calcular centroide para posición del fragmento
                    casaState.fragments.push({
                        x: fcx,
                        y: fcy,
                        velocityX: dirX / dirLen * (2 + Math.random() * 3),
                        velocityY: dirY / dirLen * (2 + Math.random() * 3),
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.2,
                        points: fragmentPoints.map(p => ({x: p.x - fcx, y: p.y - fcy})),
                        transparency: 0,
                        gravity: 0.05 + Math.random() * 0.1
                    });
                }
            }
            
            casaState.rota = true;
            
            // Programar recreación de la casa después de un tiempo
            setTimeout(() => {
                initHouse();
                casaState.rota = false;
            }, 5000); // Recrear después de 5 segundos
        }
        
        // Función para procesar el audio del micrófono
        function processAudio(audioData) {
            const bufferLength = audioData.length;
            let sum = 0;
            
            // Calcular el volumen promedio reduciendo la sensibilidad
            for (let i = 0; i < bufferLength; i++) {
                sum += Math.abs(audioData[i]);
            }
            
            const rawVolume = sum / bufferLength; // Volumen bruto
            const amplifiedVolume = Math.pow(rawVolume, 1.5) * 2.5; // Ajustado para una respuesta más controlada
            
            // Aplicar un filtro de suavizado
            casaState.audioVolume = casaState.audioVolume * 0.8 + amplifiedVolume * 0.2;
            
            // Actualizar máxima amplitud registrada si es necesario
            if (casaState.audioVolume > casaState.maxAudioAmplitude) {
                casaState.maxAudioAmplitude = casaState.audioVolume;
            }
            
            // Normalizar en relación a lo máximo observado
            const normalizedVolume = casaState.maxAudioAmplitude > 0 ? 
                casaState.audioVolume / casaState.maxAudioAmplitude : 0;
            
            // Inflado controlado por audio
            const audioInflation = normalizedVolume * casaState.inflationFactor;
            casaState.inflation = Math.min(1.0, casaState.inflation + audioInflation);
            
            // Brillo basado en inflado
            casaState.brillo = Math.pow(casaState.inflation, 2) * 0.6;
            
            // Reventar si el inflado llega al máximo
            if (casaState.inflation >= 0.95 && !casaState.rota) {
                popHouse();
            }
        }
        
        // Iniciar captura de audio (micrófono)
        function initAudio() {
            try {
                // Solicitar acceso al micrófono
                navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                    .then(function(stream) {
                        // Crear contexto de audio y conectar micrófono
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        microphone = audioContext.createMediaStreamSource(stream);
                        analyser = audioContext.createAnalyser();
                        
                        // Configurar el analizador para datos de tiempo (waveform)
                        analyser.fftSize = 1024;
                        const bufferLength = analyser.frequencyBinCount;
                        const dataArray = new Float32Array(bufferLength);
                        
                        // Conectar micrófono al analizador
                        microphone.connect(analyser);
                        
                        // Crear nodo de procesamiento en tiempo real
                        javascriptNode = audioContext.createScriptProcessor(1024, 1, 1);
                        analyser.connect(javascriptNode);
                        javascriptNode.connect(audioContext.destination);
                        
                        // Procesar datos de audio
                        javascriptNode.onaudioprocess = function() {
                            analyser.getFloatTimeDomainData(dataArray);
                            processAudio(dataArray);
                        };
                        
                        audioInitialized = true;
                        console.log("Audio inicializado correctamente");
                    })
                    .catch(function(err) {
                        console.error("Error al acceder al micrófono:", err);
                        // Seguir con funcionalidad básica sin audio
                        audioInitialized = false;
                    });
            } catch (e) {
                console.error("Error al inicializar el audio:", e);
                audioInitialized = false;
            }
        }
        
        // Actualizar lógica y posición de los fragmentos
        function updateFragments() {
            if (!casaState.rota) return;
            
            casaState.fragments.forEach(fragment => {
                // Actualizar posición
                fragment.x += fragment.velocityX;
                fragment.y += fragment.velocityY;
                fragment.rotation += fragment.rotationSpeed;
                
                // Aplicar gravedad
                fragment.velocityY += fragment.gravity;
                
                // Fricción del aire
                fragment.velocityX *= 0.99;
                fragment.velocityY *= 0.99;
                fragment.rotationSpeed *= 0.99;
                
                // Incrementar transparencia
                fragment.transparency = Math.min(0.5, fragment.transparency + 0.003);
                
                // Si el fragmento sale de la pantalla, hacerlo desaparecer más rápido
                if (fragment.y > canvas.height + 100 || 
                    fragment.x < -100 || 
                    fragment.x > canvas.width + 100) {
                    fragment.transparency = Math.min(0.9, fragment.transparency + 0.01);
                }
            });
        }
        
        // Manejar la desinflación gradual
        function deflateHouse() {
            if (casaState.rota) return;
            
            // Reducir inflado gradualmente (simulación de pérdida de aire)
            casaState.inflation = Math.max(0, casaState.inflation - 0.001);
            
            // Actualizar otros parámetros basados en inflación
            casaState.brillo = Math.pow(casaState.inflation, 2) * 0.6;
            casaState.opacidad = 1 - casaState.inflation * 0.3;
            
            // Reducir la tensión acumulada por toques con el tiempo
            casaState.tensionPorToque = Math.max(0, casaState.tensionPorToque - 0.5);
            
            // Resetear el contador de interacciones si pasa suficiente tiempo sin interactuar
            const timeSinceLastInteraction = Date.now() - casaState.lastInteractionTime;
            if (timeSinceLastInteraction > 1000) {
                casaState.interactionCount = Math.max(0, casaState.interactionCount - 1);
            }
        }
        
        // Función principal de actualización (ciclo de animación)
        function update() {
            // Actualizar lógica
            updateFragments();
            deflateHouse();
            
            // Dibujar
            drawHouse();
            
            // Continuar ciclo de animación
            requestAnimationFrame(update);
        }
        
        // Manejar interacciones de cursor/touch
        function handlePointerInteraction(x, y, isDown) {
            if (casaState.rota) {
                // Si la casa está rota, permitir arrastrar fragmentos
                if (isDown) {
                    // Comprobar si el puntero está sobre algún fragmento
                    for (let i = 0; i < casaState.fragments.length; i++) {
                        const fragment = casaState.fragments[i];
                        
                        // Transformar las coordenadas del cursor al sistema de coordenadas del fragmento
                        const dx = x - fragment.x;
                        const dy = y - fragment.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        
                        // Si está cerca del centro del fragmento, seleccionarlo
                        if (distance < 50) {
                            casaState.dragging = true;
                            casaState.dragFragment = i;
                            casaState.lastX = x;
                            casaState.lastY = y;
                            break;
                        }
                    }
                } else {
                    // Soltar fragmento
                    if (casaState.dragging && casaState.dragFragment !== null) {
                        const fragment = casaState.fragments[casaState.dragFragment];
                        // Darle velocidad basada en el movimiento del arrastre
                        const speedFactor = 0.2;
                        fragment.velocityX = (x - casaState.lastX) * speedFactor;
                        fragment.velocityY = (y - casaState.lastY) * speedFactor;
                        casaState.dragging = false;
                        casaState.dragFragment = null;
                    }
                }
            } else {
                // Si la casa no está rota, interactuar con ella
                
                // Actualizamos posición del cursor para efectos
                casaState.cursorX = x;
                casaState.cursorY = y;
                
                // Calcular centro de la casa para distancia
                let centerX = 0, centerY = 0;
                for (let i = 0; i < casaState.puntos.length - 1; i++) {
                    centerX += casaState.puntos[i].x;
                    centerY += casaState.puntos[i].y;
                }
                centerX /= (casaState.puntos.length - 1);
                centerY /= (casaState.puntos.length - 1);
                
                // Distancia del cursor al centro de la casa
                const dx = x - centerX;
                const dy = y - centerY;
                casaState.cursorDistancia = Math.sqrt(dx*dx + dy*dy);
                
                // Comprobar si el cursor está interactuando con la casa
                casaState.cursorInteraccion = isPointInHouse(x, y) || casaState.cursorDistancia < 150;
                
                if (isDown && casaState.cursorInteraccion) {
                    // Registrar tiempo de última interacción
                    casaState.lastInteractionTime = Date.now();
                    
                    // Incremento muy pequeño en la inflación por interacción
                    casaState.inflation = Math.min(1.0, casaState.inflation + casaState.mouseInflationFactor);
                    
                    // Aumentar tensión acumulada por toques (especialmente si está muy inflada)
                    const tensionIncrement = 1 + casaState.inflation * 10;
                    casaState.tensionPorToque += tensionIncrement;
                    
                    // Incrementar contador de interacciones
                    casaState.interactionCount++;
                    
                    // Reventar si la tensión por toques supera el umbral
                    if (casaState.tensionPorToque > casaState.touchThreshold) {
                        popHouse(x, y);
                    }
                    
                    // También reventar si hay muchas interacciones rápidas
                    if (casaState.interactionCount > 15) {
                        popHouse(x, y);
                    }
                    
                    // Si está arrastrando la casa (click/touch dentro)
                    if (isPointInHouse(x, y)) {
                        // Buscar el punto más cercano para distorsión
                        let closestIdx = -1;
                        let closestDist = Infinity;
                        
                        for (let i = 0; i < casaState.puntos.length - 1; i++) {
                            const p = casaState.puntos[i];
                            const dist = Math.sqrt(Math.pow(p.x - x, 2) + Math.pow(p.y - y, 2));
                            
                            if (dist < closestDist) {
                                closestDist = dist;
                                closestIdx = i;
                            }
                        }
                        
                        // Aplicar tensión al punto más cercano si se encontró uno
                        if (closestIdx >= 0 && closestDist < 100) {
                            casaState.dragging = true;
                            casaState.dragIndex = closestIdx;
                            
                            // Calcular dirección desde el centro
                            const p = casaState.puntos[closestIdx];
                            const dirX = p.x - centerX;
                            const dirY = p.y - centerY;
                            const dirLen = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
                            
                            // Mover punto en dirección radial (simulando tensión)
                            const pullStrength = 5 + casaState.inflation * 10; // Más fuerte cuando está más inflada
                            const newX = p.x + (x - p.x) * 0.3;
                            const newY = p.y + (y - p.y) * 0.3;
                            
                            // Limitar la distorsión para evitar distorsiones excesivas
                            const origX = p.origX;
                            const origY = p.origY;
                            const distFromOrig = Math.sqrt(Math.pow(newX - origX, 2) + Math.pow(newY - origY, 2));
                            
                            // Calcular tensión basada en distancia desde posición original
                            const tensionRatio = Math.min(1, distFromOrig / casaState.tensionMax);
                            casaState.tensionPorToque += tensionRatio * 5;
                            
                            // Aplicar el movimiento con limitación
                            if (distFromOrig < casaState.tensionMax) {
                                p.x = newX;
                                p.y = newY;
                            } else {
                                // Si excede la tensión máxima, reventar
                                popHouse(p.x, p.y);
                            }
                        }
                    }
                } else {
                    // Si no está presionando, devolver los puntos gradualmente a su posición original
                    if (casaState.dragging) {
                        casaState.dragging = false;
                    }
                    
                    // Restaurar forma original gradualmente
                    for (let i = 0; i < casaState.puntos.length - 1; i++) {
                        const p = casaState.puntos[i];
                        p.x = p.x + (p.origX - p.x) * casaState.elasticidad;
                        p.y = p.y + (p.origY - p.y) * casaState.elasticidad;
                    }
                }
            }
        }
        
        // Actualizar posición de fragmentos arrastrados
        function updateDraggedFragment() {
            if (casaState.dragging && casaState.dragFragment !== null) {
                const fragment = casaState.fragments[casaState.dragFragment];
                // Mover el fragmento a la posición del cursor
                fragment.x = casaState.cursorX;
                fragment.y = casaState.cursorY;
                // Detener su velocidad mientras está siendo arrastrado
                fragment.velocityX = 0;
                fragment.velocityY = 0;
                fragment.rotationSpeed *= 0.9; // Reducir rotación
            }
        }
        
        // Handlers de eventos para mouse y touch
        function handleMouseDown(e) {
            handlePointerInteraction(e.clientX, e.clientY, true);
        }
        
        function handleMouseMove(e) {
            handlePointerInteraction(e.clientX, e.clientY, e.buttons > 0);
            updateDraggedFragment();
        }
        
        function handleMouseUp(e) {
            handlePointerInteraction(e.clientX, e.clientY, false);
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                handlePointerInteraction(touch.clientX, touch.clientY, true);
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                handlePointerInteraction(touch.clientX, touch.clientY, true);
                updateDraggedFragment();
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            handlePointerInteraction(
                e.changedTouches[0].clientX,
                e.changedTouches[0].clientY,
                false
            );
        }
        
        // Manejar cambios de tamaño de ventana
        function handleResize() {
            // Guardar estado actual
            const prevInflation = casaState.inflation;
            const prevRota = casaState.rota;
            
            // Reinicializar manteniendo estados importantes
            initHouse();
            casaState.inflation = prevInflation;
            casaState.rota = prevRota;
        }
        
        // Iniciar la aplicación
        function init() {
            // Inicializar la forma de la casa
            initHouse();
            
            // Registrar event listeners
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd, {passive: false});
            window.addEventListener('resize', handleResize);
            
            // Intentar inicializar audio
            try {
                // Solo inicializar al interactuar para cumplir con políticas de autoplay
                document.addEventListener('click', function initOnInteraction() {
                    if (!audioInitialized) {
                        initAudio();
                    }
                    document.removeEventListener('click', initOnInteraction);
                });
                
                // También intentar inicializar en carga para dispositivos que lo permitan
                window.addEventListener('load', function() {
                    setTimeout(() => {
                        if (!audioInitialized) {
                            initAudio();
                        }
                    }, 1000);
                });
            } catch (e) {
                console.error("Error al configurar audio:", e);
            }
            
            // Comenzar ciclo de actualización y dibujo
            update();
        }
        
        // Iniciar todo cuando se cargue la página
        init();
    </script>
</body>
</html>
