<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Casa Globo Interactiva</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <audio id="pop-sound" src="reventar.mp3" preload="auto"></audio>

    <script>
        // Variables globales
        let audioContext;
        let analyser;
        let microphone;
        let javascriptNode;
        let audioInitialized = false;
        
        // Estado de la casa
        let casaState = {
            inflada: true,
            rota: false,
            puntos: [],         // Puntos del borde de la casa
            fragments: [],      // Fragmentos después de reventar
            dragging: false,
            dragIndex: -1,
            dragFragment: null, // Para arrastrar fragmentos
            lastX: 0,
            lastY: 0,
            inflation: 0,       // Nivel de inflado (0-1)
            opacidad: 1,        // Opacidad de la tela (inversa a inflado)
            elasticidad: 0.05,  // Qué tan rápido regresa a su forma
            tensionMax: 80,     // Tensión máxima antes de reventar
            brillo: 0,          // Nivel de brillo del látex
            bordeColor: '#8B4513', // Color café para el bordado
            cursorDistancia: 0, // Distancia del cursor a la casa
            cursorInteraccion: false // Si el cursor está interactuando con la casa
        };
        
        // Referencias a elementos del DOM
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const popSound = document.getElementById('pop-sound');
        
        // Ajustar el tamaño del canvas al tamaño de la ventana
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // Inicializar la forma de la casa con puntos de bordado
        function initHouse() {
            // Ajustar el canvas al tamaño de la ventana
            resizeCanvas();
            
            // Calcular centro relativo al canvas actual
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / 800; // Factor de escala basado en 800px
            
            // Contorno de la casa con bordes más redondeados, centrado en el canvas
            casaState.puntos = [
                {x: centerX - 100 * scale, y: centerY + 150 * scale, origX: centerX - 100 * scale, origY: centerY + 150 * scale},
                {x: centerX - 100 * scale, y: centerY + 50 * scale, origX: centerX - 100 * scale, origY: centerY + 50 * scale},
                {x: centerX - 100 * scale, y: centerY - 50 * scale, origX: centerX - 100 * scale, origY: centerY - 50 * scale},
                {x: centerX - 50 * scale, y: centerY - 100 * scale, origX: centerX - 50 * scale, origY: centerY - 100 * scale},
                {x: centerX, y: centerY - 150 * scale, origX: centerX, origY: centerY - 150 * scale},
                {x: centerX + 50 * scale, y: centerY - 100 * scale, origX: centerX + 50 * scale, origY: centerY - 100 * scale},
                {x: centerX + 100 * scale, y: centerY - 50 * scale, origX: centerX + 100 * scale, origY: centerY - 50 * scale},
                {x: centerX + 100 * scale, y: centerY + 50 * scale, origX: centerX + 100 * scale, origY: centerY + 50 * scale},
                {x: centerX + 100 * scale, y: centerY + 150 * scale, origX: centerX + 100 * scale, origY: centerY + 150 * scale},
                {x: centerX - 100 * scale, y: centerY + 150 * scale, origX: centerX - 100 * scale, origY: centerY + 150 * scale}
            ];
            
            // Añadir puntos de bordado/costura a lo largo del contorno
            casaState.puntosCostra = [];
            for (let i = 0; i < casaState.puntos.length - 1; i++) {
                const p1 = casaState.puntos[i];
                const p2 = casaState.puntos[i + 1];
                const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                const numPuntos = Math.max(5, Math.floor(dist / (10 * scale))); // Un punto cada 10px aprox, ajustado por escala
                
                for (let j = 0; j < numPuntos; j++) {
                    const t = j / numPuntos;
                    const x = p1.x + (p2.x - p1.x) * t;
                    const y = p1.y + (p2.y - p1.y) * t;
                    
                    // Añadir pequeña variación aleatoria para dar aspecto más natural
                    const variacion = 2 * scale;
                    const offsetX = (Math.random() - 0.5) * variacion;
                    const offsetY = (Math.random() - 0.5) * variacion;
                    
                    casaState.puntosCostra.push({
                        x: x + offsetX,
                        y: y + offsetY,
                        size: (1 + Math.random() * 1.5) * scale // Tamaño variable, escalado
                    });
                }
            }
            
            casaState.inflation = 0;
            casaState.opacidad = 1;
            casaState.brillo = 0;
            casaState.rota = false;
            casaState.fragments = [];
        }
        
        // Comprobar si un punto está dentro del contorno de la casa
        function isPointInHouse(x, y) {
            let inside = false;
            let j = casaState.puntos.length - 1;
            
            for (let i = 0; i < casaState.puntos.length; i++) {
                const xi = casaState.puntos[i].x;
                const yi = casaState.puntos[i].y;
                const xj = casaState.puntos[j].x;
                const yj = casaState.puntos[j].y;
                
                const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
                j = i;
            }
            
            return inside;
        }
        
        // Dibujar cuadrícula en la superficie para dar efecto de látex (solo dentro de la casa)
        function drawGrid(context) {
            context.save();
            
            // Calcular centro de la casa
            let centerX = 0, centerY = 0;
            for (let i = 0; i < casaState.puntos.length - 1; i++) {
                centerX += casaState.puntos[i].x;
                centerY += casaState.puntos[i].y;
            }
            centerX /= (casaState.puntos.length - 1);
            centerY /= (casaState.puntos.length - 1);
            
            // Calcular el tamaño aproximado de la casa para escalar la cuadrícula
            let maxDist = 0;
            for (let i = 0; i < casaState.puntos.length - 1; i++) {
                const dx = casaState.puntos[i].x - centerX;
                const dy = casaState.puntos[i].y - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                maxDist = Math.max(maxDist, dist);
            }
            
            // Color base de la cuadrícula basado en inflación
            const opacidadBase = 0.1 + casaState.brillo * 0.3;
            const rojoBrillo = Math.min(255, 220 + casaState.inflation * 35);
            const azulBrillo = Math.max(180, 230 - casaState.inflation * 50);
            
            context.strokeStyle = `rgba(${rojoBrillo}, 255, ${azulBrillo}, ${opacidadBase})`;
            context.lineWidth = 0.5;
            
            // Aplicar recorte al path de la casa para que la cuadrícula solo se dibuje dentro
            context.beginPath();
            casaState.puntos.forEach((punto, i) => {
                if (i === 0) {
                    context.moveTo(punto.x, punto.y);
                } else {
                    context.lineTo(punto.x, punto.y);
                }
            });
            context.closePath();
            context.clip();
            
            // Dibujar líneas horizontales y verticales
            const scale = Math.min(canvas.width, canvas.height) / 800;
            const gridSize = 10 * scale;
            const gridRange = maxDist * 1.2;
            
            for (let i = -gridRange; i <= gridRange; i += gridSize) {
                // Líneas horizontales curvadas según inflación
                context.beginPath();
                context.moveTo(centerX - gridRange, centerY + i);
                context.bezierCurveTo(
                    centerX - gridRange/2, centerY + i * (1 + casaState.inflation * 0.3),
                    centerX + gridRange/2, centerY + i * (1 + casaState.inflation * 0.3),
                    centerX + gridRange, centerY + i
                );
                context.stroke();
                
                // Líneas verticales curvadas según inflación
                context.beginPath();
                context.moveTo(centerX + i, centerY - gridRange);
                context.bezierCurveTo(
                    centerX + i * (1 + casaState.inflation * 0.3), centerY - gridRange/2,
                    centerX + i * (1 + casaState.inflation * 0.3), centerY + gridRange/2,
                    centerX + i, centerY + gridRange
                );
                context.stroke();
            }
            
            context.restore();
        }
        
        // Dibujar puntadas de bordado realistas
        function drawStitches(context, points, isFragment = false) {
            context.save();
            
            // Configuración para las puntadas
            if (isFragment) {
                // Para fragmentos, ajustar el dibujo de las puntadas
                context.lineWidth = 1.5;
                context.strokeStyle = casaState.bordeColor;
                
                // Dibujar las puntadas como pequeños segmentos inclinados en zigzag
                context.beginPath();
                
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    const numPuntos = Math.max(3, Math.floor(dist / 5));
                    
                    for (let j = 0; j < numPuntos; j++) {
                        const t1 = j / numPuntos;
                        const t2 = (j + 0.5) / numPuntos;
                        
                        const x1 = p1.x + (p2.x - p1.x) * t1;
                        const y1 = p1.y + (p2.y - p1.y) * t1;
                        
                        const x2 = p1.x + (p2.x - p1.x) * t2;
                        const y2 = p1.y + (p2.y - p1.y) * t2;
                        
                        // Desplazamiento perpendicular para el zigzag
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        
                        if (len > 0) {
                            const perpX = -dy / len * 2;
                            const perpY = dx / len * 2;
                            
                            // Alternar la dirección para zigzag
                            const dir = j % 2 === 0 ? 1 : -1;
                            
                            context.moveTo(x1, y1);
                            context.lineTo(x2 + perpX * dir, y2 + perpY * dir);
                        }
                    }
                }
                
                context.stroke();
            } else {
                // Para la casa completa, dibujar puntadas individuales en los puntos predefinidos
                for (let i = 0; i < casaState.puntosCostra.length; i++) {
                    const punto = casaState.puntosCostra[i];
                    const size = punto.size * (1 + casaState.inflation * 0.2);
                    
                    // Dibujar el punto con un estilo de puntada cruzada
                    context.lineWidth = 1.5;
                    context.strokeStyle = casaState.bordeColor;
                    
                    context.beginPath();
                    context.moveTo(punto.x - size, punto.y - size);
                    context.lineTo(punto.x + size, punto.y + size);
                    context.stroke();
                    
                    context.beginPath();
                    context.moveTo(punto.x + size, punto.y - size);
                    context.lineTo(punto.x - size, punto.y + size);
                    context.stroke();
                }
            }
            
            context.restore();
        }
        
        // Dibujar la casa según su estado actual
        function drawHouse() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (casaState.rota) {
                // Dibujar los fragmentos de la casa rota
                casaState.fragments.forEach(fragment => {
                    ctx.save();
                    ctx.translate(fragment.x, fragment.y);
                    ctx.rotate(fragment.rotation);
                    
                    // Dibujar el fragmento
                    ctx.beginPath();
                    fragment.points.forEach((point, i) => {
                        if (i === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.closePath();
                    
                    // Efecto de brillo para látex mejorado
                    const gradientFill = ctx.createRadialGradient(0, 0, 5, 0, 0, 50);
                    
                    // Colores más realistas para el látex
                    gradientFill.addColorStop(0, `rgba(255, 255, 255, ${0.9 - fragment.transparency})`);
                    gradientFill.addColorStop(0.3, `rgba(240, 240, 255, ${0.8 - fragment.transparency})`);
                    gradientFill.addColorStop(0.6, `rgba(230, 230, 250, ${0.7 - fragment.transparency})`);
                    gradientFill.addColorStop(0.8, `rgba(220, 220, 245, ${0.6 - fragment.transparency})`);
                    gradientFill.addColorStop(1, `rgba(200, 200, 240, ${0.5 - fragment.transparency})`);
                    
                    ctx.fillStyle = gradientFill;
                    ctx.fill();
                    
                    // Dibujar el contorno del fragmento (muy sutil)
                    ctx.strokeStyle = 'rgba(200, 200, 230, 0.4)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                    
                    // Dibujar el bordado con realismo
                    drawStitches(ctx, fragment.points, true);
                    
                    ctx.restore();
                });
            } else {
                // Dibujar la casa inflada con efecto redondeado y brillante
                ctx.beginPath();
                
                // Dibujar la casa con curvas Bezier para bordes más redondeados
                ctx.moveTo(casaState.puntos[0].x, casaState.puntos[0].y);
                
                // Calcular centro para efectos
                let centerX = 0, centerY = 0;
                for (let i = 0; i < casaState.puntos.length - 1; i++) {
                    centerX += casaState.puntos[i].x;
                    centerY += casaState.puntos[i].y;
                }
                centerX /= (casaState.puntos.length - 1);
                centerY /= (casaState.puntos.length - 1);
                
                for (let i = 0; i < casaState.puntos.length - 1; i++) {
                    const current = casaState.puntos[i];
                    const next = casaState.puntos[i + 1];
                    
                    if (i === 0 || i === casaState.puntos.length - 2) {
                        // Para el primer y último segmento, usamos línea recta
                        ctx.lineTo(next.x, next.y);
                    } else {
                        // Para los demás segmentos, usamos curvas
                        const cp1x = current.x + (next.x - current.x) / 3;
                        const cp1y = current.y + (next.y - current.y) / 3;
                        const cp2x = current.x + 2 * (next.x - current.x) / 3;
                        const cp2y = current.y + 2 * (next.y - current.y) / 3;
                        
                        // Ajustar los puntos de control según la inflación
                        const inflateFactor = 1 + casaState.inflation * 0.3;
                        const midX = (current.x + next.x) / 2;
                        const midY = (current.y + next.y) / 2;
                        
                        // Dirección desde el centro hacia el punto medio
                        const dx = midX - centerX;
                        const dy = midY - centerY;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        
                        // Ajustar puntos de control para curvar hacia afuera
                        if (len > 0) {
                            const inflateX = dx / len * casaState.inflation * 20;
                            const inflateY = dy / len * casaState.inflation * 20;
                            
                            ctx.bezierCurveTo(
                                cp1x + inflateX, cp1y + inflateY,
                                cp2x + inflateX, cp2y + inflateY,
                                next.x, next.y
                            );
                        } else {
                            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
                        }
                    }
                }
                
                ctx.closePath();
                
                // Cálculo de radio para efectos
                let maxRadius = 0;
                for (let i = 0; i < casaState.puntos.length - 1; i++) {
                    const dx = casaState.puntos[i].x - centerX;
                    const dy = casaState.puntos[i].y - centerY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    maxRadius = Math.max(maxRadius, dist);
                }
                const radius = maxRadius + casaState.inflation * (maxRadius * 0.3);
                
                // Efecto de brillo para el látex con degradado mejorado
                const gradient = ctx.createRadialGradient(
                    centerX - maxRadius * 0.2, centerY - maxRadius * 0.2, radius * 0.2,
                    centerX, centerY, radius * 1.2
                );
                
                // Ajustar colores según nivel de inflado para efecto más realista
                const alphaBase = 0.9 - casaState.inflation * 0.2;
                
                // Simulación de translucidez del látex
                gradient.addColorStop(0, `rgba(255, 255, 255, ${0.9 + casaState.brillo * 0.1})`);
                gradient.addColorStop(0.3, `rgba(250, 250, 255, ${0.85 + casaState.brillo * 0.15})`);
                gradient.addColorStop(0.5, `rgba(240, 240, 250, ${0.8 + casaState.brillo * 0.2})`);
                gradient.addColorStop(0.7, `rgba(230, 230, 245, ${0.75 + casaState.brillo * 0.15})`);
                gradient.addColorStop(0.9, `rgba(220, 220, 240, ${alphaBase})`);
                gradient.addColorStop(1, `rgba(200, 200, 235, ${alphaBase * 0.9})`);
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Dibujar el contorno (muy sutil)
                ctx.strokeStyle = 'rgba(200, 200, 230, 0.4)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
                
                // Dibujar cuadrícula para efecto de látex (solo dentro de la casa)
                drawGrid(ctx);
                
                // Dibujar el bordado con puntadas realistas
                drawStitches(ctx, casaState.puntos);
                
                // Añadir brillo especular para efecto de látex
                ctx.beginPath();
                const highlightRadius = maxRadius * 0.2 + casaState.inflation * maxRadius * 0.1;
                const highlightGradient = ctx.createRadialGradient(
                    centerX - maxRadius * 0.15, centerY - maxRadius * 0.15, 5,
                    centerX - maxRadius * 0.15, centerY - maxRadius * 0.15, highlightRadius
                );
                highlightGradient.addColorStop(0, `rgba(255, 255, 255, ${0.7 + casaState.brillo * 0.3})`);
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = highlightGradient;
                ctx.arc(centerX - maxRadius * 0.15, centerY - maxRadius * 0.15, highlightRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Mostrar la interacción del cursor
                if (casaState.cursorInteraccion) {
                    // Efecto de distorsión en la dirección del cursor
                    const cursorEffect = 1 - Math.min(1, casaState.cursorDistancia / (maxRadius * 1.5));
                    if (cursorEffect > 0.1) {
                        ctx.beginPath();
                        const pulseRadius = 15 + Math.sin(Date.now() / 200) * 5;
                        const pulseGradient = ctx.createRadialGradient(
                            casaState.cursorX, casaState.cursorY, 1,
                            casaState.cursorX, casaState.cursorY, pulseRadius * (1 + casaState.inflation)
                        );
                        pulseGradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * cursorEffect})`);
                        pulseGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.fillStyle = pulseGradient;
                        ctx.arc(casaState.cursorX, casaState.cursorY, pulseRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        // Actualizar la física y el estado de la casa
        function updateHouse() {
            if (casaState.rota) {
                // Actualizar fragmentos de la casa rota
                casaState.fragments.forEach(fragment => {
                    // Si no lo estamos arrastrando
                    if (fragment !== casaState.dragFragment) {
                        // Aplicar gravedad y velocidad
                        fragment.y += fragment.velocityY;
                        fragment.x += fragment.velocityX;
                        fragment.velocityY += 0.1; // Gravedad
                        fragment.rotation += fragment.rotationSpeed;
                        
                        // Desvanecer gradualmente
                        fragment.transparency += 0.0005; // Muy lento para que permanezcan visibles
                        
                        // Mantener los fragmentos dentro del canvas con rebotes
                        const margin = 20; // Margen para mantener fragmentos visibles
                        
                        if (fragment.y > canvas.height - margin) {
                            fragment.y = canvas.height - margin;
                            fragment.velocityY *= -0.6; // Rebote más elástico
                            fragment.velocityX *= 0.9; // Fricción
                            fragment.rotationSpeed *= 0.9; // Reducir rotación en impacto
                        }
                        
                        if (fragment.y < margin) {
                            fragment.y = margin;
                            fragment.velocityY *= -0.6;
                        }
                        
                        if (fragment.x > canvas.width - margin) {
                            fragment.x = canvas.width - margin;
                            fragment.velocityX *= -0.6;
                        }
                        
                        if (fragment.x < margin) {
                            fragment.x = margin;
                            fragment.velocityX *= -0.6;
                        }
                    }
                });
            } else {
                // Física de elasticidad mejorada para la casa
                casaState.puntos.forEach((punto, index) => {
                    if (index > 0 && index < casaState.puntos.length - 1) {
                        // Fuerza para regresar al punto original
                        const dx = punto.origX - punto.x;
                        const dy = punto.origY - punto.y;
                        
                        // Aplicar fuerza con elasticidad variable según inflación
                        const elastActual = casaState.elasticidad * (1 - casaState.inflation * 0.3);
                        punto.x += dx * elastActual;
                        punto.y += dy * elastActual;
                        
                        // Añadir pequeña oscilación para simular material elástico
                        const oscillation = Math.sin(Date.now() / 300 + index) * 0.2;
                        punto.x += dx * oscillation * casaState.inflation;
                        punto.y += dy * oscillation * casaState.inflation;
                    }
                });
                
                // Reducir gradualmente la inflación si no hay entrada de audio
                if (casaState.inflation > 0) {
                    casaState.inflation -= 0.002; // Reducción más lenta
                    if (casaState.inflation < 0) casaState.inflation = 0;
                }
                
                // Ajustar brillo con la inflación
                casaState.brillo = casaState.inflation * 0.8;
                
                // Comprobar si la casa está muy estirada y debe romperse
                checkTension();
            }
        }
        
        // Comprobar si la tensión de la casa es excesiva
        function checkTension() {
            let maxDistance = 0;
            
            // Calcular la distancia máxima de un punto a su posición original
            casaState.puntos.forEach((punto, index) => {
                if (index > 0 && index < casaState.puntos.length - 1) {
                    const dx = punto.x - punto.origX;
                    const dy = punto.y - punto.origY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    maxDistance = Math.max(maxDistance, distance);
                }
            });
            
            // Si se supera la tensión máxima, romper la casa
            if (maxDistance > casaState.tensionMax + casaState.inflation * casaState.tensionMax) {
                breakHouse();
            }
        }
        
        // Romper la casa en fragmentos
        function breakHouse() {
            if (casaState.rota) return; // Ya está rota, no hacer nada
            
            casaState.rota = true;
            casaState.fragments = [];
            
            // Reproducir sonido de ruptura
            playPopSound();
            
            // Calcular centro para física de fragmentos
            let centerX = 0, centerY = 0;
            for (let i = 0; i < casaState.puntos.length - 1; i++) {
                centerX += casaState.puntos[i].x;
                centerY += casaState.puntos[i].y;
            }
            centerX /= (casaState.puntos.length - 1);
            centerY /= (casaState.puntos.length - 1);
            
            // Número de fragmentos aleatorio entre 6 y 10
            const numFragmentos = 6 + Math.floor(Math.random() * 5);
            
            // Crear fragmentos tipo "pedazos de globo reventado"
            for (let i = 0; i < numFragmentos; i++) {
                // Para cada fragmento, crear una forma irregular
                const fragmentPoints = [];
                const numPuntos = 5 + Math.floor(Math.random() * 5); // 5-9 puntos
                const angleStep = Math.PI * 2 / numPuntos;
                const baseSize = 20 + Math.random() * 30;
                
                // Posición inicial del fragmento (aleatoria pero cerca del centro)
                const offsetX = (Math.random() - 0.5) * 50;
                const offsetY = (Math.random() - 0.5) * 50;
                const fragmentX = centerX + offsetX;
                const fragmentY = centerY + offsetY;
                
                // Crear puntos para el fragmento
                for (let j = 0; j < numPuntos; j++) {
                    const angle = j * angleStep + Math.random() * 0.5;
                    const radius = baseSize + Math.random() * 10;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    fragmentPoints.push({x, y});
                }
                
                // Cerrar el polígono
                fragmentPoints.push({...fragmentPoints[0]});
                
                // Dirección de movimiento alejándose del centro
                const dirX = offsetX === 0 ? Math.random() - 0.5 : offsetX / Math.abs(offsetX);
                const dirY = offsetY === 0 ? Math.random() - 0.5 : offsetY / Math.abs(offsetY);
                
                // Crear el fragmento con propiedades físicas
                casaState.fragments.push({
                    points: fragmentPoints,
                    x: fragmentX,
                    y: fragmentY,
                    velocityX: dirX * (1 + Math.random() * 2),
                    velocityY: dirY * (1 + Math.random() * 2) - 3, // Impulso hacia arriba
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.08,
                    transparency: 0, // Empezar visible, luego se desvanece
                });
            }
        }
        
        // Reproducir sonido de ruptura
        function playPopSound() {
            try {
                popSound.currentTime = 0;
                popSound.play().catch(err => {
                    console.warn("No se pudo reproducir el sonido:", err);
                });
            } catch (e) {
                console.warn("Error al intentar reproducir sonido:", e);
            }
        }
        
        // Función para procesar la entrada del micrófono y actualizar la inflación
        function processAudio() {
            if (!audioInitialized) return;
            
            // Obtener datos de frecuencia
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            
            // Calcular volumen promedio
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const average = sum / dataArray.length;
            
            // Normalizar entre 0 y 1, con umbral mínimo
            const normalizedVolume = Math.max(0, average - 20) / (255 - 20);
            
            // Actualizar inflación, evitando cambios bruscos
            if (normalizedVolume > casaState.inflation) {
                // Inflar rápidamente con el audio
                casaState.inflation += (normalizedVolume - casaState.inflation) * 0.2;
            } else {
                // Desinflar más lentamente
                casaState.inflation += (normalizedVolume - casaState.inflation) * 0.05;
            }
            
            // Limitar entre 0 y 1
            casaState.inflation = Math.max(0, Math.min(1, casaState.inflation));
        }
        
        // Inicializar el audio y acceso al micrófono
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                
                // Solicitar acceso al micrófono
                navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                    .then(stream => {
                        microphone = audioContext.createMediaStreamSource(stream);
                        microphone.connect(analyser);
                        
                        // Node para procesar los datos de audio
                        javascriptNode = audioContext.createScriptProcessor(2048, 1, 1);
                        javascriptNode.connect(audioContext.destination);
                        analyser.connect(javascriptNode);
                        
                        javascriptNode.onaudioprocess = processAudio;
                        audioInitialized = true;
                    })
                    .catch(err => {
                        console.error("Error accediendo al micrófono:", err);
                    });
            } catch (e) {
                console.error("Error inicializando audio:", e);
            }
        }
        
        // Control de arrastre de la casa
        function startDrag(x, y) {
            if (casaState.rota) {
                // Comprobar si se hace clic en algún fragmento
                for (let i = 0; i < casaState.fragments.length; i++) {
                    const fragment = casaState.fragments[i];
                    
                    // Comprobar colisión simple con centro del fragmento
                    const dx = fragment.x - x;
                    const dy = fragment.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 30) { // Radio para detección
                        casaState.dragging = true;
                        casaState.dragFragment = fragment;
                        casaState.lastX = x;
                        casaState.lastY = y;
                        break;
                    }
                }
            } else {
                // Comprobar si se hace clic dentro de la casa
                if (isPointInHouse(x, y)) {
                    casaState.dragging = true;
                    
                    // Encontrar el punto más cercano para arrastrar
                    let minDist = Infinity;
                    casaState.dragIndex = -1;
                    
                    for (let i = 0; i < casaState.puntos.length - 1; i++) {
                        const dx = casaState.puntos[i].x - x;
                        const dy = casaState.puntos[i].y - y;
                        const dist = dx * dx + dy * dy;
                        
                        if (dist < minDist) {
                            minDist = dist;
                            casaState.dragIndex = i;
                        }
                    }
                    
                    casaState.lastX = x;
                    casaState.lastY = y;
                }
            }
        }
        
        function drag(x, y) {
            if (!casaState.dragging) return;
            
            const deltaX = x - casaState.lastX;
            const deltaY = y - casaState.lastY;
            
            if (casaState.rota) {
                // Arrastrar fragmento
                if (casaState.dragFragment) {
                    casaState.dragFragment.x += deltaX;
                    casaState.dragFragment.y += deltaY;
                    casaState.dragFragment.velocityX = deltaX * 0.1;
                    casaState.dragFragment.velocityY = deltaY * 0.1;
                }
            } else {
                // Arrastrar punto de la casa
                if (casaState.dragIndex >= 0) {
                    casaState.puntos[casaState.dragIndex].x += deltaX;
                    casaState.puntos[casaState.dragIndex].y += deltaY;
                }
            }
            
            casaState.lastX = x;
            casaState.lastY = y;
        }
        
        function endDrag() {
            casaState.dragging = false;
            casaState.dragIndex = -1;
            casaState.dragFragment = null;
        }
        
        // Reiniciar la casa
        function resetHouse() {
            initHouse();
            drawHouse();
        }
        
        // Actualizar información del cursor para efectos de interacción
        function updateCursorInfo(x, y) {
            if (!casaState.rota) {
                // Calcular distancia al centro
                let centerX = 0, centerY = 0;
                for (let i = 0; i < casaState.puntos.length - 1; i++) {
                    centerX += casaState.puntos[i].x;
                    centerY += casaState.puntos[i].y;
                }
                centerX /= (casaState.puntos.length - 1);
                centerY /= (casaState.puntos.length - 1);
                
                const dx = x - centerX;
                const dy = y - centerY;
                casaState.cursorDistancia = Math.sqrt(dx * dx + dy * dy);
                casaState.cursorInteraccion = isPointInHouse(x, y);
                casaState.cursorX = x;
                casaState.cursorY = y;
            }
        }
        
        // === Event Listeners ===
        canvas.addEventListener('mousedown', function(e) {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            startDrag(e.offsetX, e.offsetY);
        });
        
        canvas.addEventListener('mousemove', function(e) {
            drag(e.offsetX, e.offsetY);
            updateCursorInfo(e.offsetX, e.offsetY);
        });
        
        canvas.addEventListener('mouseup', function() {
            endDrag();
        });
        
        canvas.addEventListener('mouseleave', function() {
            endDrag();
            casaState.cursorInteraccion = false;
        });
        
        // Soporte para touch en dispositivos móviles
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            startDrag(x, y);
        });
        
        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            drag(x, y);
            updateCursorInfo(x, y);
        });
        
        canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            endDrag();
        });
        
        // Ajustar canvas cuando cambia el tamaño de la ventana
        window.addEventListener('resize', function() {
            resizeCanvas();
            resetHouse();
        });
        
        // Inicializar audio al hacer clic en el canvas
        canvas.addEventListener('click', function() {
            if (!audioInitialized) {
                initAudio();
            }
        });
        
        // === Inicialización y bucle de animación ===
        function init() {
            resetHouse();
            
            // Animación
            function animate() {
                requestAnimationFrame(animate);
                updateHouse();
                drawHouse();
            }
            
            animate();
        }
        
        // Iniciar cuando la página esté lista
        init();
    </script>
</body>
</html>
