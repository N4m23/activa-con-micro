<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Casa Interactiva Inflable</title>
<style>
  body {
    margin: 0; background: #f0f0f0; overflow: hidden;
    display: flex; justify-content: center; align-items: center; height: 100vh;
    user-select: none;
  }
  #casa {
    position: relative;
    width: 200px; height: 200px;
    background: repeating-linear-gradient(
      45deg,
      #fff,
      #fff 10px,
      #eee 10px,
      #eee 20px
    );
    border: 4px solid #444;
    border-radius: 20px;
    box-sizing: border-box;
    cursor: grab;
    background-image:
      repeating-linear-gradient(45deg, #fff 0, #fff 10px, #eee 10px, #eee 20px),
      url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><text x="0" y="15" font-family="monospace" font-size="15" fill="gray">✿</text></svg>');
    background-repeat: repeat;
    background-blend-mode: multiply;
    opacity: 1;
    transition: opacity 0.5s ease;
  }
  #bordado {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    border: 2px dashed #888;
    border-radius: 20px;
    box-sizing: border-box;
    transition: border-color 0.3s ease;
  }
  .fragmento {
    position: absolute;
    background: repeating-linear-gradient(
      45deg,
      #fff,
      #fff 10px,
      #eee 10px,
      #eee 20px
    );
    border: 2px solid #444;
    border-radius: 10px;
    box-sizing: border-box;
    cursor: grab;
    user-select: none;
  }
</style>
</head>
<body>

<div id="casa">
  <div id="bordado"></div>
</div>

<audio id="audioPop" src="https://www.soundjay.com/misc/sounds/bubble-pop-1.mp3" preload="auto"></audio>

<script>
  // Variables
  const casa = document.getElementById('casa');
  const bordado = document.getElementById('bordado');
  const audioPop = document.getElementById('audioPop');
  let isInflated = false;
  let isPopped = false;
  let maxScale = 2.5;
  let minScale = 1;
  let currentScale = 1;
  let tension = 0; // Simula tensión del bordado
  let fragments = [];

  // Para manipulación con cursor
  let isDragging = false;
  let dragStart = null;
  let casaPos = {x: 0, y: 0};
  let deformOffset = {x: 0, y: 0};

  // Para manipulación de fragmentos
  let draggedFragment = null;
  let offsetFragment = {x: 0, y: 0};

  // Función para actualizar la apariencia
  function updateCasa() {
    // Escala la casa según currentScale
    casa.style.transform = `scale(${currentScale}) translate(${deformOffset.x}px, ${deformOffset.y}px)`;
    // Opacidad y bordado según tensión
    let opacity = 1 - (currentScale - 1) / (maxScale - 1) * 0.7;
    casa.style.opacity = opacity;
    let borderColorIntensity = Math.min(255, Math.floor(tension * 255));
    bordado.style.borderColor = `rgb(${borderColorIntensity},0,0)`;
  }

  // Función para fragmentar la casa (post-reventar)
  function fragmentarCasa() {
    isPopped = true;
    audioPop.play();

    // Ocultar casa original
    casa.style.display = 'none';

    // Crear fragmentos
    const fragmentCount = 6;
    const rect = casa.getBoundingClientRect();
    for (let i = 0; i < fragmentCount; i++) {
      const frag = document.createElement('div');
      frag.classList.add('fragmento');
      frag.style.width = (rect.width / 3) + 'px';
      frag.style.height = (rect.height / 2) + 'px';

      // Posición inicial fragmentos dispersos alrededor del centro
      frag.style.left = (window.innerWidth / 2 + (Math.random() - 0.5) * 300) + 'px';
      frag.style.top = (window.innerHeight / 2 + (Math.random() - 0.5) * 300) + 'px';

      // Añadir textura similar
      frag.style.background = casa.style.background;
      frag.style.borderColor = bordado.style.borderColor;

      document.body.appendChild(frag);
      fragments.push(frag);

      // Eventos para arrastrar fragmentos
      frag.addEventListener('mousedown', (e) => {
        draggedFragment = frag;
        offsetFragment.x = e.clientX - frag.offsetLeft;
        offsetFragment.y = e.clientY - frag.offsetTop;
        frag.style.cursor = 'grabbing';
      });
    }
  }

  // Micrófono y audio input para inflar la casa
  async function setupMic() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({audio: true});
      const audioContext = new AudioContext();
      const source = audioContext.createMediaStreamSource(stream);
      const analyser = audioContext.createAnalyser();
      source.connect(analyser);
      analyser.fftSize = 256;
      const dataArray = new Uint8Array(analyser.frequencyBinCount);

      function analyze() {
        if (isPopped) return; // No inflar si ya reventó
        analyser.getByteFrequencyData(dataArray);
        let volume = dataArray.reduce((a,b) => a+b, 0) / dataArray.length / 255;
        // Mapear volumen a escala
        let targetScale = minScale + volume * (maxScale - minScale);
        targetScale = Math.min(maxScale * 1.1, Math.max(minScale, targetScale));
        // Actualizar tensión y escala suavemente
        tension = Math.min(1, (targetScale - 1) / (maxScale - 1));
        currentScale += (targetScale - currentScale) * 0.1;

        // Si escala supera límite, reventar
        if (currentScale > maxScale * 0.95) {
          fragmentarCasa();
        } else {
          updateCasa();
        }
        requestAnimationFrame(analyze);
      }
      analyze();
    } catch (err) {
      alert('No se pudo acceder al micrófono. La casa no se inflará.');
    }
  }

  // Manipulación con cursor para deformar la casa
  casa.addEventListener('mousedown', (e) => {
    if (isPopped) return;
    isDragging = true;
    dragStart = {x: e.clientX, y: e.clientY};
    casa.style.cursor = 'grabbing';
  });
  window.addEventListener('mouseup', () => {
    isDragging = false;
    dragStart = null;
    casa.style.cursor = 'grab';
    deformOffset = {x: 0, y: 0};
    updateCasa();
  });
  window.addEventListener('mousemove', (e) => {
    if (isDragging && !isPopped) {
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      deformOffset = {x: dx / 5, y: dy / 5};
      // Aumentar tensión con deformación
      tension = Math.min(1, Math.sqrt(dx*dx + dy*dy) / 150);
      // Si deformación muy grande, reventar
      if (tension > 0.9) {
        fragmentarCasa();
      } else {
        updateCasa();
      }
    }
  });

  // Manipulación fragmentos post-reventar
  window.addEventListener('mouseup', () => {
    if (draggedFragment) {
      draggedFragment.style.cursor = 'grab';
      draggedFragment = null;
    }
  });
  window.addEventListener('mousemove', (e) => {
    if (draggedFragment) {
      draggedFragment.style.left = (e.clientX - offsetFragment.x) + 'px';
      draggedFragment.style.top = (e.clientY - offsetFragment.y) + 'px';
    }
  });

  // Inicializar
  updateCasa();
  setupMic();
</script>

</body>
</html>

