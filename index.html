<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tela Reactiva al Audio</title>
    <style>
        body {/* Estilos sin cambios */}
        .container {/* Estilos sin cambios */}
        canvas {/* Estilos sin cambios */}
        .controls {/* Estilos sin cambios */}
        button {/* Estilos sin cambios */}
        button:hover {/* Estilos sin cambios */}
        .info {/* Estilos sin cambios */}
        .info h1 {/* Estilos sin cambios */}
        .info p {/* Estilos sin cambios */}
        .hidden {/* Estilos sin cambios */}
        .volume-indicator {/* Estilos sin cambios */}
        .volume-level {/* Estilos sin cambios */}
    </style>
</head>
<body>
    <div class="container">
        <div class="info">
            <h1>El acto de respirar como gesto de presencia, pausa y cuidado</h1>
            <p>Haz clic en el botón y respira para dar vida a la tela con tu aliento.</p>
        </div>
        <canvas id="canvas"></canvas>
        <div class="controls">
            <button id="mic-button">Activar respiración</button>
            <div class="volume-indicator hidden" id="volume-indicator">
                <div class="volume-level" id="volume-level"></div>
            </div>
        </div>
    </div>

    <script>
        // Configuración del canvas y la simulación (sin cambios)
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const micButton = document.getElementById('mic-button');
        const volumeIndicator = document.getElementById('volume-indicator');
        const volumeLevel = document.getElementById('volume-level');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Variables para el micrófono (sin breathSound)
        let audioContext;
        let analyzer;
        let microphone;
        let micActive = false;
        let dataArray;

        // Configuración de la simulación de tela (sin cambios)
        const clothWidth = 400;
        const clothHeight = 300;
        const numPointsX = 30;
        const numPointsY = 20;
        const restDistance = clothWidth / numPointsX;

        // Clase Punto para la simulación de tela (sin cambios)
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.originalX = x;
                this.originalY = y;
                this.vx = 0;
                this.vy = 0;
                this.pinned = false;
                this.mass = 1;
            }
        }

        // Clase tela para simulación (modificado)
        class Cloth {
            constructor() {
                this.points = [];

                // Crear puntos de la tela
                for (let y = 0; y <= numPointsY; y++) {
                    for (let x = 0; x <= numPointsX; x++) {
                        const u = x / numPointsX;
                        const v = y / numPointsY;

                        // Posición inicial en forma de curva suave
                        const px = canvas.width / 2 - clothWidth / 2 + clothWidth * u;
                        const py = canvas.height / 2 - clothHeight / 2 + clothHeight * v;

                        const point = new Point(px, py);

                        // Fijar solo los puntos superiores para que cuelgue
                        if (y === 0) {
                            point.pinned = true;
                        }

                        this.points.push(point);
                    }
                }

                // Generar el índice para acceder a los puntos fácilmente
                this.getPoint = (x, y) => this.points[y * (numPointsX + 1) + x];

                // Conectar puntos con restricciones elásticas
                this.constraints = [];

                // Restricciones estructurales horizontales
                for (let y = 0; y <= numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y),
                            distance: restDistance
                        });
                    }
                }

                // Restricciones estructurales verticales
                for (let x = 0; x <= numPointsX; x++) {
                    for (let y = 0; y < numPointsY; y++) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x, y + 1),
                            distance: restDistance
                        });
                    }
                }

                // Restricciones de corte diagonal 1
                for (let y = 0; y < numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y + 1),
                            distance: Math.sqrt(restDistance * restDistance * 2)
                        });
                    }
                }

                // Restricciones de corte diagonal 2
                for (let y = 0; y < numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        this.constraints.push({
                            p1: this.getPoint(x + 1, y),
                            p2: this.getPoint(x, y + 1),
                            distance: Math.sqrt(restDistance * restDistance * 2)
                        });
                    }
                }
            }

            update(dt, windForceX, windForceY) {
                // Constantes físicas
                const GRAVITY = 0.0981 * dt;
                const DAMPING = 0.97;
                const DRAG = 1 - 0.02;

                // Aplicar fuerzas
                for (let i = 0; i < this.points.length; i++) {
                    const point = this.points[i];
                    if (!point.pinned) {
                        // Acumular fuerzas
                        point.vy += GRAVITY;

                        // Aplicar fuerza del viento
                        point.vx += windForceX;
                        point.vy += windForceY;

                        // Limitar la extensión hacia abajo (opcional, pero recomendado)
                        if (point.y > point.originalY + 200) {
                            point.y = point.originalY + 200;
                            point.vy *= -0.5; // Rebotar un poco
                        }

                        // Verlet integration
                        const prevX = point.x;
                        const prevY = point.y;

                        point.x += point.vx;
                        point.y += point.vy;

                        // Actualizar velocidades con amortiguación
                        point.vx = (point.x - prevX) * DAMPING;
                        point.vy = (point.y - prevY) * DAMPING;
                    }
                }

                // Resolver restricciones
                const iterations = 15;
                for (let i = 0; i < iterations; i++) {
                    for (let j = 0; j < this.constraints.length; j++) {
                        const constraint = this.constraints[j];
                        const p1 = constraint.p1;
                        const p2 = constraint.p2;

                        // Cálculo de la distancia actual
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const currentDistance = Math.sqrt(dx * dx + dy * dy);

                        if (currentDistance > 0) {
                            // Calcular dirección
                            const diff = (constraint.distance - currentDistance) / currentDistance;

                            // Distribuir corrección
                            const percent1 = p1.pinned ? 0 : 0.5;
                            const percent2 = p2.pinned ? 0 : 0.5;

                            const offsetX = dx * diff;
                            const offsetY = dy * diff;

                            p1.x -= offsetX * percent1;
                            p1.y -= offsetY * percent1;

                            p2.x += offsetX * percent2;
                            p2.y += offsetY * percent2;
                        }
                    }
                }
            }

            draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Dibujar la tela con degradado suave
                for (let y = 0; y < numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        const p1 = this.getPoint(x, y);
                        const p2 = this.getPoint(x + 1, y);
                        const p3 = this.getPoint(x + 1, y + 1);
                        const p4 = this.getPoint(x, y + 1);

                        // Crear gradiente para simular sombras
                        const centerX = (p1.x + p2.x + p3.x + p4.x) / 4;
                        const centerY = (p1.y + p2.y + p3.y + p4.y) / 4;

                        // Calcular normal aproximada para efectos de iluminación
                        const nx = (p3.y - p1.y);
                        const ny = -(p3.x - p1.x);
                        const norm = Math.sqrt(nx * nx + ny * ny);

                        // Normalizar normal
                        const normalX = nx / norm;
                        const normalY = ny / norm;

                        // Calcular valor de iluminación basado en la normal
                        const lightX = 0.5;
                        const lightY = -1;
                        const lightIntensity = (normalX * lightX + normalY * lightY) * 0.5 + 0.5;

                        // Color basado en iluminación
                        const brightness = Math.floor(210 + lightIntensity * 45);

                        // Dibujar cuadrilátero
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.lineTo(p3.x, p3.y);
                        ctx.lineTo(p4.x, p4.y);
                        ctx.closePath();

                        // Gradiente radial para simular pliegues y ondulaciones
                        const gradient = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, restDistance * 2
                        );

                        gradient.addColorStop(0, `rgba(${brightness}, ${brightness}, ${brightness}, 0.9)`);
                        gradient.addColorStop(1, `rgba(${brightness-20}, ${brightness-20}, ${brightness-20}, 0.85)`);

                        ctx.fillStyle = gradient;
                        ctx.fill();

                        // Líneas muy suaves para simular pliegues
                        ctx.strokeStyle = `rgba(255, 255, 255, 0.06)`;
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
            }
        }

        // Crear tela
        const cloth = new Cloth();

        // Función para inicializar el micrófono (modificado)
        function initMicrophone() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({
                        audio: true,
                        video: false
                    })
                    .then(function(stream) {
                        // Configurar el análisis de audio
                        audioContext = new(window.AudioContext || window.webkitAudioContext)();
                        microphone = audioContext.createMediaStreamSource(stream);
                        analyzer = audioContext.createAnalyser();
                        analyzer.fftSize = 256;
                        microphone.connect(analyzer);

                        dataArray = new Uint8Array(analyzer.frequencyBinCount);

                        micActive = true;
                        micButton.textContent = "Respiración activada";
                        volumeIndicator.classList.remove('hidden');
                    })
                    .catch(function(err) {
                        console.log('Error al acceder al micrófono: ' + err);
                        alert('No se pudo acceder al micrófono. Por favor, verifica los permisos.');
                    });
            } else {
                alert('Tu navegador no soporta acceso al micrófono.');
            }
        }

        // Listener para el botón de micrófono (sin breathSound)
        micButton.addEventListener('click', function() {
            if (!micActive) {
                initMicrophone();
            } else {
                // Desactivar micrófono si ya está activo
                micActive = false;
                if (microphone) {
                    microphone.disconnect();
                }
                micButton.textContent = "Activar respiración";
                volumeIndicator.classList.add('hidden');
            }
        });

        // Animación
        function animate() {
            // Obtener el volumen del micrófono (modificado)
            let windForceX = 0;
            let windForceY = 0;

            if (micActive) {
                analyzer.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i];
                }
                const average = sum / dataArray.length;

                // Mapear el volumen a la fuerza del viento
                const windStrength = average / 100; // Ajustar este valor

                // Aplicar la fuerza del viento en forma de onda
                windForceX = Math.sin(Date.now() / 500) * windStrength;
                windForceY = Math.cos(Date.now() / 500) * windStrength;

                // Mostrar el volumen en el indicador (opcional)
                const volumePercentage = Math.min(average, 100);
                volumeLevel.style.width = volumePercentage + '%';
            }

            // Aplicar fuerza del viento a la tela
            cloth.update(16, windForceX, windForceY);
            cloth.draw();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
