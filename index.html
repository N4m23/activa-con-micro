<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Casa Globo Interactiva</title>
<style>
  body {
    margin: 0; padding: 0; overflow: hidden;
    background-color: #000000;
  }
  canvas {
    display: block;
    margin: auto;
    background-color: #000000;
    box-shadow: 0 0 15px rgba(255,255,255,0.1);
  }
</style>
</head>
<body>
<canvas id="canvas" width="800" height="600"></canvas>
<audio id="popSound" src="reventar.mp3" preload="auto"></audio>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const popSound = document.getElementById('popSound');

  // Estado de la casa
  const casaState = {
    puntos: [],
    inflation: 0,       // 0 a 1 (inflado)
    opacidad: 0.7,      // opacidad inicial tela
    brillo: 0,          // brillo látex
    bordeColor: '#8B4513', // café oscuro para bordado
    rota: false,
    fragments: [],
    dragging: false,
    dragIndex: -1,
    lastMouseX: 0,
    lastMouseY: 0,
    posX: 400,
    posY: 300,
    velX: 0,
    velY: 0,
  };

  // Inicializa puntos de la casa (contorno con bordes redondeados)
  function initHouse() {
    casaState.puntos = [
      {x: 300, y: 400, origX: 300, origY: 400},
      {x: 300, y: 300, origX: 300, origY: 300},
      {x: 300, y: 200, origX: 300, origY: 200},
      {x: 350, y: 150, origX: 350, origY: 150},
      {x: 400, y: 100, origX: 400, origY: 100},
      {x: 450, y: 150, origX: 450, origY: 150},
      {x: 500, y: 200, origX: 500, origY: 200},
      {x: 500, y: 300, origX: 500, origY: 300},
      {x: 500, y: 400, origX: 500, origY: 400},
    ];
  }

  // Dibuja cuadrícula gris con transparencia variable
  function drawGrid() {
    const alpha = casaState.opacidad;
    ctx.strokeStyle = `rgba(150,150,150,${alpha})`;
    ctx.lineWidth = 0.5;
    const spacing = 15;
    const minX = 300, maxX = 500;
    const minY = 100, maxY = 400;

    for(let x = minX; x <= maxX; x += spacing){
      ctx.beginPath();
      ctx.moveTo(x, minY);
      ctx.lineTo(x, maxY);
      ctx.stroke();
    }
    for(let y = minY; y <= maxY; y += spacing){
      ctx.beginPath();
      ctx.moveTo(minX, y);
      ctx.lineTo(maxX, y);
      ctx.stroke();
    }
  }

  // Dibuja bordado café/rojo con puntadas discontinuas
  function drawEmbroidery() {
    ctx.strokeStyle = casaState.bordeColor;
    ctx.lineWidth = 3;
    ctx.setLineDash([10,10]); // puntadas

    // Marco puerta
    ctx.beginPath();
    ctx.moveTo(350,320);
    ctx.lineTo(350,380);
    ctx.lineTo(450,380);
    ctx.lineTo(450,320);
    ctx.closePath();
    ctx.stroke();

    // Líneas internas
    ctx.beginPath();
    ctx.moveTo(400,320);
    ctx.lineTo(400,380);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(350,350);
    ctx.lineTo(450,350);
    ctx.stroke();

    ctx.setLineDash([]);
  }

  // Dibuja la casa inflada con textura y brillo
  function drawHouse() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if(casaState.rota){
      drawFragments();
      return;
    }

    // Curvas para bordes redondeados
    ctx.beginPath();
    ctx.moveTo(casaState.puntos[0].x, casaState.puntos[0].y);
    for(let i=1; i < casaState.puntos.length; i++){
      const p0 = casaState.puntos[i-1];
      const p1 = casaState.puntos[i];
      const xc = (p0.x + p1.x)/2;
      const yc = (p0.y + p1.y)/2;
      ctx.quadraticCurveTo(p0.x, p0.y, xc, yc);
    }
    ctx.closePath();

    // Gradiente para tela mate a brillo látex
    const alpha = casaState.opacidad;
    const grad = ctx.createRadialGradient(400, 250, 50, 400, 250, 200);
    grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
    grad.addColorStop(1, `rgba(255,255,255,0)`);
    ctx.fillStyle = grad;
    ctx.fill();

    // Cuadrícula
    drawGrid();

    // Bordado
    drawEmbroidery();

    // Brillo látex adicional
    if(casaState.inflation > 0.5){
      const brilloAlpha = (casaState.inflation - 0.5)*2*0.3;
      const radialGrad = ctx.createRadialGradient(400, 200, 10, 400, 200, 150);
      radialGrad.addColorStop(0, `rgba(255,255,255,${brilloAlpha})`);
      radialGrad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = radialGrad;
      ctx.beginPath();
      ctx.ellipse(400, 200, 150, 100, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Genera fragmentos al reventar
  function createFragments() {
    casaState.fragments = [];
    const basePoints = casaState.puntos;
    const nFragments = 12;
    for(let i=0; i<nFragments; i++){
      // Fragmento con puntos aleatorios dentro de la casa
      const fragment = {
        points: [],
        x: 400 + random(-50,50),
        y: 300 + random(-50,50),
        rotation: random(-0.1,0.1),
        rotationSpeed: random(-0.01,0.01),
        transparency: 0,
        transparencySpeed: 0.005
      };
      // Crear polígono simple con 4 puntos aleatorios cercanos
      for(let j=0; j<4; j++){
        fragment.points.push({
          x: random(-30,30),
          y: random(-30,30)
        });
      }
      casaState.fragments.push(fragment);
    }
  }

  // Dibuja fragmentos animados
  function drawFragments() {
    casaState.fragments.forEach(fragment => {
      ctx.save();
      ctx.translate(fragment.x, fragment.y);
      ctx.rotate(fragment.rotation);
      ctx.beginPath();
      fragment.points.forEach((p,i) => {
        if(i===0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      });
      ctx.closePath();

      // Brillo látex fragmento
      const grad = ctx.createRadialGradient(0,0,5,0,0,50);
      grad.addColorStop(0, `rgba(255,255,255,${0.8 - fragment.transparency})`);
      grad.addColorStop(1, `rgba(200,200,200,${0.5 - fragment.transparency})`);
      ctx.fillStyle = grad;
      ctx.fill();

      // Bordado café
      ctx.strokeStyle = casaState.bordeColor;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Cuadrícula dentro fragmento
      drawGridFragment(fragment);

      ctx.restore();

      // Animar fragmento
      fragment.x += random(-1,1);
      fragment.y += random(-1,1);
      fragment.rotation += fragment.rotationSpeed;
      fragment.transparency += fragment.transparencySpeed;
      if(fragment.transparency > 0.7) fragment.transparencySpeed *= -1;
      if(fragment.transparency < 0) fragment.transparencySpeed *= -1;
    });
  }

  // Dibuja cuadrícula en fragmento (simplificada)
  function drawGridFragment(fragment) {
    ctx.strokeStyle = `rgba(150,150,150,${0.3})`;
    ctx.lineWidth = 0.3;
    const spacing = 10;
    for(let x = -30; x <= 30; x += spacing){
      ctx.beginPath();
      ctx.moveTo(x, -30);
      ctx.lineTo(x, 30);
      ctx.stroke();
    }
    for(let y = -30; y <= 30; y += spacing){
      ctx.beginPath();
      ctx.moveTo(-30, y);
      ctx.lineTo(30, y);
      ctx.stroke();
    }
  }

  // Variables para micrófono
  let audioContext, analyser, microphone, javascriptNode;
  let volume = 0;

  // Variables para arrastre
  let dragging = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;

  // Inicialización
  function initMic() {
    navigator.mediaDevices.getUserMedia({audio:true}).then(stream => {
      audioContext = new AudioContext();
      microphone = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.smoothingTimeConstant = 0.8;
      analyser.fftSize = 1024;

      microphone.connect(analyser);

      const dataArray = new Uint8Array(analyser.frequencyBinCount);

      function analyze() {
        analyser.getByteFrequencyData(dataArray);
        let sum = 0;
        for(let i=0; i<dataArray.length; i++){
          sum += dataArray[i];
        }
        volume = sum / dataArray.length / 255; // Normalizado 0-1
        requestAnimationFrame(analyze);
      }
      analyze();
    }).catch(err => {
      console.warn('Micrófono no permitido o error:', err);
    });
  }

  // Actualizar estado de la casa
  function updateState() {
    if(casaState.rota) return;

    // Inflado por volumen
    const targetInflation = Math.min(volume * 3, 1); // Escalar volumen para inflado máximo 1
    casaState.inflation += (targetInflation - casaState.inflation) * 0.1;

    // Opacidad inversa al inflado
    casaState.opacidad = 0.7 - 0.4 * casaState.inflation;
    casaState.brillo = casaState.inflation;

    // Actualizar puntos para inflado (deformación simple)
    casaState.puntos.forEach(p => {
      const dx = p.origX - 400;
      const dy = p.origY - 300;
      p.x = 400 + dx * (1 + casaState.inflation * 0.3);
      p.y = 300 + dy * (1 + casaState.inflation * 0.3);
    });

    // Detectar ruptura si inflado muy alto y estiramiento (simplificado)
    if(casaState.inflation > 0.95){
      casaState.rota = true;
      createFragments();
      popSound.play();
    }
  }

  // Manejo de arrastre
  canvas.addEventListener('mousedown', e => {
    if(casaState.rota) return;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Ver si clic dentro de la casa (aprox rectángulo)
    if(mouseX > 300 && mouseX < 500 && mouseY > 100 && mouseY < 400){
      dragging = true;
      dragOffsetX = mouseX - casaState.posX;
      dragOffsetY = mouseY - casaState.posY;
    }
  });

  canvas.addEventListener('mouseup', e => {
    dragging = false;
  });

  canvas.addEventListener('mousemove', e => {
    if(dragging && !casaState.rota){
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Actualizar posición de la casa y puntos
      const dx = mouseX - dragOffsetX - casaState.posX;
      const dy = mouseY - dragOffsetY - casaState.posY;
      casaState.posX += dx;
      casaState.posY += dy;

      casaState.puntos.forEach(p => {
        p.x += dx;
        p.y += dy;
        p.origX += dx;
        p.origY += dy;
      });
    }
  });

  // Loop principal
  function loop() {
    updateState();
    drawHouse();
    requestAnimationFrame(loop);
  }

  // Inicializar
  function init() {
    initHouse();
    initMic();
    loop();
  }

  init();

})();
</script>
</body>
</html>
