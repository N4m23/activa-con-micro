<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>El acto de respirar - Presencia, pausa y cuidado</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #fff;
      font-family: Arial, sans-serif;
    }

    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      height: 300px;
      max-width: 90vw;
      max-height: 70vh;
      background-color: #000;
      display: block;
    }

    .controls {
      position: absolute;
      bottom: 30px;
      z-index: 10;
      text-align: center;
      width: 100%;
      display: flex;
      justify-content: center;
      pointer-events: auto;
    }

    button {
      background-color: rgba(255, 255, 255, 0.2);
      color: #fff;
      border: 1px solid #fff;
      padding: 10px 20px;
      border-radius: 30px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
      outline: none;
    }

    button:hover {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .info {
      position: absolute;
      top: 30px;
      text-align: center;
      max-width: 600px;
      padding: 0 20px;
      font-size: 18px;
      line-height: 1.5;
      opacity: 0.8;
      pointer-events: none;
      user-select: none;
    }

    .info h1 {
      font-weight: normal;
      font-size: 24px;
      margin-bottom: 10px;
    }

    .info p {
      margin-bottom: 5px;
    }

    .hidden {
      display: none;
    }

    .volume-indicator {
      width: 50px;
      height: 10px;
      background-color: rgba(255, 255, 255, 0.2);
      margin-left: 15px;
      border-radius: 5px;
      overflow: hidden;
    }

    .volume-level {
      height: 100%;
      width: 0%;
      background-color: rgba(255, 255, 255, 0.8);
      transition: width 0.1s;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="info">
      <h1>El acto de respirar como gesto de presencia, pausa y cuidado</h1>
      <p>Haz clic en el botón y respira para dar vida a la tela con tu aliento.</p>
    </div>

    <canvas id="canvas" width="400" height="300"></canvas>

    <div class="controls">
      <button id="mic-button">Activar Micrófono</button>
      <div class="volume-indicator hidden" id="volume-indicator">
        <div class="volume-level" id="volume-level"></div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const micButton = document.getElementById('mic-button');
    const volumeIndicator = document.getElementById('volume-indicator');
    const volumeLevel = document.getElementById('volume-level');

    let audioContext;
    let analyzer;
    let microphone;
    let micActive = false;
    let dataArray;

    const clothWidth = 400;
    const clothHeight = 300;
    const numPointsX = 30;
    const numPointsY = 20;
    const restDistance = clothWidth / numPointsX;

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.originalX = x;
        this.originalY = y;
        this.vx = 0;
        this.vy = 0;
        this.pinned = false;
        this.mass = 1;
      }
    }

    class Cloth {
      constructor() {
        this.points = [];

        for (let y = 0; y <= numPointsY; y++) {
          for (let x = 0; x <= numPointsX; x++) {
            const u = x / numPointsX;
            const v = y / numPointsY;

            const px = clothWidth * u;
            const py = clothHeight * v;

            const point = new Point(px, py);

            if (y === 0) point.pinned = true;

            this.points.push(point);
          }
        }

        this.getPoint = (x, y) => this.points[y * (numPointsX + 1) + x];

        this.constraints = [];

        // Horizontales
        for (let y = 0; y <= numPointsY; y++) {
          for (let x = 0; x < numPointsX; x++) {
            this.constraints.push({
              p1: this.getPoint(x, y),
              p2: this.getPoint(x + 1, y),
              distance: restDistance,
            });
          }
        }

        // Verticales
        for (let x = 0; x <= numPointsX; x++) {
          for (let y = 0; y < numPointsY; y++) {
            this.constraints.push({
              p1: this.getPoint(x, y),
              p2: this.getPoint(x, y + 1),
              distance: restDistance,
            });
          }
        }

        // Diagonales 1
        for (let y = 0; y < numPointsY; y++) {
          for (let x = 0; x < numPointsX; x++) {
            this.constraints.push({
              p1: this.getPoint(x, y),
              p2: this.getPoint(x + 1, y + 1),
              distance: Math.sqrt(restDistance * restDistance * 2),
            });
          }
        }

        // Diagonales 2
        for (let y = 0; y < numPointsY; y++) {
          for (let x = 0; x < numPointsX; x++) {
            this.constraints.push({
              p1: this.getPoint(x + 1, y),
              p2: this.getPoint(x, y + 1),
              distance: Math.sqrt(restDistance * restDistance * 2),
            });
          }
        }
      }

      update(dt) {
        const GRAVITY = 0.05 * dt; // menos gravedad para suavidad
        const DAMPING = 0.9;       // más amortiguación para menos rigidez

        for (let i = 0; i < this.points.length; i++) {
          const point = this.points[i];
          if (!point.pinned) {
            point.vy += GRAVITY;

            const prevX = point.x;
            const prevY = point.y;

            point.x += point.vx;
            point.y += point.vy;

            // Limitar extensión vertical (máx 50px abajo del original)
            const maxY = point.originalY + 50;
            if (point.y > maxY) {
              point.y = maxY;
              point.vy *= -0.3; // rebote amortiguado
            }

            point.vx = (point.x - prevX) * DAMPING;
            point.vy = (point.y - prevY) * DAMPING;
          }
        }

        const iterations = 25; // más iteraciones para suavidad
        for (let i = 0; i < iterations; i++) {
          for (let j = 0; j < this.constraints.length; j++) {
            const c = this.constraints[j];
            const p1 = c.p1;
            const p2 = c.p2;

            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 0) {
              const diff = (c.distance - dist) / dist;
              const percent1 = p1.pinned ? 0 : 0.5;
              const percent2 = p2.pinned ? 0 : 0.5;

              const offsetX = dx * diff;
              const offsetY = dy * diff;

              p1.x -= offsetX * percent1;
              p1.y -= offsetY * percent1;

              p2.x += offsetX * percent2;
              p2.y += offsetY * percent2;
            }
          }
        }
      }

      applyWindForce(forceX, forceY) {
        for (let i = 0; i < this.points.length; i++) {
          const point = this.points[i];
          if (!point.pinned) {
            const randomX = (Math.random() - 0.5) * 0.05;
            const randomY = (Math.random() - 0.5) * 0.05;

            point.vx += forceX + randomX;
            point.vy += forceY + randomY;
          }
        }
      }

      draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let y = 0; y < numPointsY; y++) {
          for (let x = 0; x < numPointsX; x++) {
            const p1 = this.getPoint(x, y);
            const p2 = this.getPoint(x + 1, y);
            const p3 = this.getPoint(x + 1, y + 1);
            const p4 = this.getPoint(x, y + 1);

            const centerX = (p1.x + p2.x + p3.x + p4.x) / 4;
            const centerY = (p1.y + p2.y + p3.y + p4.y) / 4;

            const nx = p3.y - p1.y;
            const ny = -(p3.x - p1.x);
            const norm = Math.sqrt(nx * nx + ny * ny);

            const normalX = nx / norm;
            const normalY = ny / norm;

            const lightX = 0.5;
            const lightY = -1;
            const lightIntensity = (normalX * lightX + normalY * lightY) * 0.5 + 0.5;

            const brightness = Math.floor(210 + lightIntensity * 45);

            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.lineTo(p4.x, p4.y);
            ctx.closePath();

            const gradient = ctx.createRadialGradient(
              centerX,
              centerY,
              0,
              centerX,
              centerY,
              restDistance * 2
            );

            gradient.addColorStop(0, `rgba(${brightness}, ${brightness}, ${brightness}, 0.9)`);
            gradient.addColorStop(1, `rgba(${brightness - 20}, ${brightness - 20}, ${brightness - 20}, 0.85)`);

            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.strokeStyle = `rgba(255, 255, 255, 0.06)`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
        }
      }
    }

    const cloth = new Cloth();

    function initMicrophone() {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices
          .getUserMedia({ audio: true, video: false })
          .then(function (stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            microphone = audioContext.createMediaStreamSource(stream);
            analyzer = audioContext.createAnalyser();
            analyzer.fftSize = 256;
            microphone.connect(analyzer);

            dataArray = new Uint8Array(analyzer.frequencyBinCount);

            micActive = true;
            micButton.textContent = "Micrófono activado";
            volumeIndicator.classList.remove("hidden");
          })
          .catch(function (err) {
            console.log("Error al acceder al micrófono: " + err);
            alert("No se pudo acceder al micrófono. Por favor, verifica los permisos.");
          });
      } else {
        alert("Tu navegador no soporta acceso al micrófono.");
      }
    }

    micButton.addEventListener("click", function () {
      if (!micActive) {
        initMicrophone();
      } else {
        micActive = false;
        if (microphone) microphone.disconnect();
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        micButton.textContent = "Activar Micrófono";
        volumeIndicator.classList.add("hidden");

        // Reiniciar velocidades para detener movimiento residual
        cloth.points.forEach((point) => {
          point.vx = 0;
          point.vy = 0;
          point.x = point.originalX;
          point.y = point.originalY;
        });
      }
    });

    let lastTime = performance.now();

    function animate() {
      const currentTime = performance.now();
      const deltaTime = (currentTime - lastTime) / 16;
      lastTime = currentTime;

      let micLevel = 0;

      if (micActive && analyzer) {
        analyzer.getByteFrequencyData(dataArray);

        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        micLevel = sum / dataArray.length / 255;

        volumeLevel.style.width = micLevel * 100 + "%";

        const breathForce = micLevel * 0.15;
        const time = currentTime * 0.001;
        const waveX = Math.sin(time) * breathForce;
        const waveY = Math.cos(time) * breathForce * 0.5;

        cloth.applyWindForce(waveX, waveY);
      } else {
        volumeLevel.style.width = "0%";
        // No aplicar fuerzas cuando micrófono apagado
      }

      cloth.update(deltaTime);
      cloth.draw();

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
