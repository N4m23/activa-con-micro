<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Casa Globo Interactiva</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000000; /* Fondo negro */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #canvas-container {
            position: relative;
            width: 800px;
            height: 600px;
        }
        
        canvas {
            border: 1px solid #333;
            background-color: #000000; /* Fondo negro */
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
        }
        
        #restart {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
        }
        
        #restart:hover {
            background-color: #45a049;
        }
        
        #mic-status {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas" width="800" height="600"></canvas>
        <button id="restart">Reiniciar</button>
        <div id="mic-status">Micrófono: Desactivado</div>
    </div>

    <audio id="pop-sound" src="reventar.mp3" preload="auto"></audio>

    <script>
        // Variable para almacenar el audio context
        let audioContext;
        let analyser;
        let microphone;
        let javascriptNode;
        
        // Estado de la casa
        let casaState = {
            inflada: true,
            rota: false,
            puntos: [],         // Puntos del borde de la casa
            fragments: [],      // Fragmentos después de reventar
            dragging: false,
            dragIndex: -1,
            lastX: 0,
            lastY: 0,
            inflation: 0,       // Nivel de inflado (0-1)
            opacidad: 1,        // Opacidad de la tela (inversa a inflado)
            elasticidad: 0.05,  // Qué tan rápido regresa a su forma
            tensionMax: 80,     // Tensión máxima antes de reventar
            brillo: 0,          // Nivel de brillo del látex
            bordeColor: '#8B4513' // Color café para el bordado
        };
        
        // Referencias a elementos del DOM
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const restartButton = document.getElementById('restart');
        const micStatus = document.getElementById('mic-status');
        const popSound = document.getElementById('pop-sound');
        
        // Inicializar la forma de la casa
        function initHouse() {
            // Contorno de la casa con bordes más redondeados
            casaState.puntos = [
                {x: 300, y: 400, origX: 300, origY: 400},
                {x: 300, y: 300, origX: 300, origY: 300},
                {x: 300, y: 200, origX: 300, origY: 200},
                {x: 350, y: 150, origX: 350, origY: 150},
                {x: 400, y: 100, origX: 400, origY: 100},
                {x: 450, y: 150, origX: 450, origY: 150},
                {x: 500, y: 200, origX: 500, origY: 200},
                {x: 500, y: 300, origX: 500, origY: 300},
                {x: 500, y: 400, origX: 500, origY: 400},
                {x: 300, y: 400, origX: 300, origY: 400}
            ];
            
            casaState.inflation = 0;
            casaState.opacidad = 1;
            casaState.brillo = 0;
            casaState.rota = false;
            casaState.fragments = [];
        }
        
        // Dibujar cuadrícula en la superficie para dar efecto de látex
        function drawGrid(context, points) {
            const centerX = (Math.min(...points.map(p => p.x)) + Math.max(...points.map(p => p.x))) / 2;
            const centerY = (Math.min(...points.map(p => p.y)) + Math.max(...points.map(p => p.y))) / 2;
            
            context.save();
            context.strokeStyle = `rgba(255, 255, 255, ${0.1 + casaState.brillo * 0.2})`;
            context.lineWidth = 0.5;
            
            // Dibujar líneas horizontales y verticales
            for (let i = -50; i <= 50; i += 10) {
                context.beginPath();
                context.moveTo(centerX - 100, centerY + i);
                context.bezierCurveTo(
                    centerX - 50, centerY + i * (1 + casaState.inflation * 0.2),
                    centerX + 50, centerY + i * (1 + casaState.inflation * 0.2),
                    centerX + 100, centerY + i
                );
                context.stroke();
                
                context.beginPath();
                context.moveTo(centerX + i, centerY - 100);
                context.bezierCurveTo(
                    centerX + i * (1 + casaState.inflation * 0.2), centerY - 50,
                    centerX + i * (1 + casaState.inflation * 0.2), centerY + 50,
                    centerX + i, centerY + 100
                );
                context.stroke();
            }
            
            context.restore();
        }
        
        // Dibujar la casa según su estado actual
        function drawHouse() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (casaState.rota) {
                // Dibujar los fragmentos de la casa rota
                casaState.fragments.forEach(fragment => {
                    ctx.save();
                    ctx.translate(fragment.x, fragment.y);
                    ctx.rotate(fragment.rotation);
                    
                    // Dibujar el fragmento
                    ctx.beginPath();
                    fragment.points.forEach((point, i) => {
                        if (i === 0) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    });
                    ctx.closePath();
                    
                    // Efecto de brillo para látex
                    const gradientFill = ctx.createRadialGradient(0, 0, 5, 0, 0, 50);
                    gradientFill.addColorStop(0, `rgba(255, 255, 255, ${0.8 - fragment.transparency})`);
                    gradientFill.addColorStop(0.7, `rgba(220, 220, 240, ${0.6 - fragment.transparency})`);
                    gradientFill.addColorStop(1, `rgba(200, 200, 230, ${0.5 - fragment.transparency})`);
                    ctx.fillStyle = gradientFill;
                    ctx.fill();
                    
                    // Dibujar el bordado con color café
                    ctx.strokeStyle = casaState.bordeColor;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Dibujar cuadrícula en el fragmento para efecto de látex
                    drawGrid(ctx, fragment.points);
                    
                    ctx.restore();
                });
            } else {
                // Dibujar la casa inflada con efecto redondeado y brillante
                ctx.beginPath();
                
                // Dibujar la casa con curvas Bezier para bordes más redondeados
                ctx.moveTo(casaState.puntos[0].x, casaState.puntos[0].y);
                
                for (let i = 0; i < casaState.puntos.length - 1; i++) {
                    const current = casaState.puntos[i];
                    const next = casaState.puntos[i + 1];
                    
                    if (i === 0 || i === casaState.puntos.length - 2) {
                        // Para el primer y último segmento, usamos línea recta
                        ctx.lineTo(next.x, next.y);
                    } else {
                        // Para los demás segmentos, usamos curvas
                        const cp1x = current.x + (next.x - current.x) / 3;
                        const cp1y = current.y + (next.y - current.y) / 3;
                        const cp2x = current.x + 2 * (next.x - current.x) / 3;
                        const cp2y = current.y + 2 * (next.y - current.y) / 3;
                        
                        // Ajustar los puntos de control según la inflación
                        const inflateFactor = 1 + casaState.inflation * 0.3;
                        const midX = (current.x + next.x) / 2;
                        const midY = (current.y + next.y) / 2;
                        const centerX = 400;
                        const centerY = 250;
                        
                        // Dirección desde el centro hacia el punto medio
                        const dx = midX - centerX;
                        const dy = midY - centerY;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        
                        // Ajustar puntos de control para curvar hacia afuera
                        if (len > 0) {
                            const inflateX = dx / len * casaState.inflation * 20;
                            const inflateY = dy / len * casaState.inflation * 20;
                            
                            ctx.bezierCurveTo(
                                cp1x + inflateX, cp1y + inflateY,
                                cp2x + inflateX, cp2y + inflateY,
                                next.x, next.y
                            );
                        } else {
                            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, next.x, next.y);
                        }
                    }
                }
                
                ctx.closePath();
                
                // Efecto de brillo para el látex con degradado
                const centerX = 400;
                const centerY = 250;
                const radius = 150 + casaState.inflation * 50;
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, radius * 0.2,
                    centerX - 40, centerY - 40, radius * 1.2
                );
                
                // Colores del degradado según nivel de inflado
                const alpha = 0.9 - casaState.inflation * 0.2;
                gradient.addColorStop(0, `rgba(255, 255, 255, ${0.8 + casaState.brillo * 0.2})`);
                gradient.addColorStop(0.5, `rgba(230, 230, 240, ${0.7 + casaState.brillo * 0.2})`);
                gradient.addColorStop(1, `rgba(200, 200, 230, ${alpha})`);
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Dibujar el bordado con color café
                ctx.strokeStyle = casaState.bordeColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Añadir cuadrícula para efecto de látex
                drawGrid(ctx, casaState.puntos);
                
                // Añadir brillo especular para efecto de látex
                ctx.beginPath();
                const highlightRadius = 25 + casaState.inflation * 15;
                const highlightGradient = ctx.createRadialGradient(
                    centerX - 30, centerY - 30, 5,
                    centerX - 30, centerY - 30, highlightRadius
                );
                highlightGradient.addColorStop(0, `rgba(255, 255, 255, ${0.7 + casaState.brillo * 0.3})`);
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = highlightGradient;
                ctx.arc(centerX - 30, centerY - 30, highlightRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Actualizar la física y el estado de la casa
        function updateHouse() {
            if (casaState.rota) {
                // Actualizar fragmentos de la casa rota
                casaState.fragments.forEach(fragment => {
                    // Aplicar gravedad y velocidad
                    fragment.y += fragment.velocityY;
                    fragment.x += fragment.velocityX;
                    fragment.velocityY += 0.1; // Gravedad
                    fragment.rotation += fragment.rotationSpeed;
                    fragment.transparency += 0.003; // Desvanecer gradualmente
                    
                    // Rebotar en los bordes
                    if (fragment.y > canvas.height + 50) {
                        fragment.y = canvas.height + 50;
                        fragment.velocityY *= -0.6;
                    }
                });
                
                // Comprobar si todos los fragmentos se han desvanecido
                const allFaded = casaState.fragments.every(f => f.transparency > 0.5);
                if (allFaded) {
                    restartButton.style.display = 'block';
                }
            } else {
                // Aplicar fuerzas de elasticidad a los puntos
                casaState.puntos.forEach((punto, index) => {
                    if (index > 0 && index < casaState.puntos.length - 1) {
                        // Fuerza para regresar al punto original
                        const dx = punto.origX - punto.x;
                        const dy = punto.origY - punto.y;
                        
                        // Aplicar fuerza con la elasticidad configurada
                        punto.x += dx * casaState.elasticidad;
                        punto.y += dy * casaState.elasticidad;
                    }
                });
                
                // Reducir gradualmente la inflación si no hay entrada de audio
                if (casaState.inflation > 0) {
                    casaState.inflation -= 0.01;
                    if (casaState.inflation < 0) casaState.inflation = 0;
                }
                
                // Ajustar brillo con la inflación
                casaState.brillo = casaState.inflation * 0.8;
                
                // Comprobar si la casa está muy estirada y debe romperse
                checkTension();
            }
        }
        
        // Comprobar si la tensión de la casa es excesiva
        function checkTension() {
            let maxDistance = 0;
            
            // Calcular la distancia máxima de un punto a su posición original
            casaState.puntos.forEach((punto, index) => {
                if (index > 0 && index < casaState.puntos.length - 1) {
                    const dx = punto.x - punto.origX;
                    const dy = punto.y - punto.origY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    maxDistance = Math.max(maxDistance, distance);
                }
            });
            
            // Si se supera la tensión máxima, romper la casa
            if (maxDistance > casaState.tensionMax) {
                breakHouse();
            }
        }
        
        // Romper la casa en fragmentos
        function breakHouse() {
            // Reproducir sonido de reventar
            playPopSound();
            
            // Crear fragmentos de la casa rota
            casaState.rota = true;
            casaState.fragments = [];
            
            // Número de fragmentos (más fragmentos con mayor inflación)
            const numFragments = 8 + Math.floor(casaState.inflation * 5);
            
            // Crear cada fragmento con propiedades físicas
            for (let i = 0; i < numFragments; i++) {
                const centerX = 400;
                const centerY = 250;
                
                // Ángulo y distancia para este fragmento
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 30 + 10;
                
                // Posición inicial
                const startX = centerX + Math.cos(angle) * distance;
                const startY = centerY + Math.sin(angle) * distance;
                
                // Velocidad inicial (explosión desde el centro)
                const velocityMag = 2 + Math.random() * 3 + casaState.inflation * 2;
                const velocityX = Math.cos(angle) * velocityMag;
                const velocityY = Math.sin(angle) * velocityMag;
                
                // Crear puntos aleatorios para el fragmento
                const fragmentPoints = [];
                const numPoints = 5 + Math.floor(Math.random() * 3);
                const fragmentSize = 15 + Math.random() * 25;
                
                for (let j = 0; j < numPoints; j++) {
                    const pointAngle = j * (Math.PI * 2 / numPoints);
                    const pointDist = fragmentSize * (0.8 + Math.random() * 0.4);
                    
                    fragmentPoints.push({
                        x: Math.cos(pointAngle) * pointDist,
                        y: Math.sin(pointAngle) * pointDist
                    });
                }
                
                // Añadir el fragmento a la lista
                casaState.fragments.push({
                    x: startX,
                    y: startY,
                    velocityX: velocityX,
                    velocityY: velocityY,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.1,
                    points: fragmentPoints,
                    transparency: 0
                });
            }
        }
        
        // Reproducir el sonido de reventar
        function playPopSound() {
            popSound.currentTime = 0;
            popSound.play().catch(e => console.log("Error reproduciendo sonido:", e));
        }
        
        // Configurar los eventos de mouse
        function setupMouseEvents() {
            canvas.addEventListener('mousedown', function(e) {
                if (casaState.rota) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Detectar si el clic está en un punto de la casa
                for (let i = 0; i < casaState.puntos.length; i++) {
                    const punto = casaState.puntos[i];
                    const dx = punto.x - mouseX;
                    const dy = punto.y - mouseY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 20) {
                        casaState.dragging = true;
                        casaState.dragIndex = i;
                        casaState.lastX = mouseX;
                        casaState.lastY = mouseY;
                        break;
                    }
                }
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (!casaState.dragging || casaState.rota) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Solo mover puntos que no son los bordes fijos
                if (casaState.dragIndex > 0 && casaState.dragIndex < casaState.puntos.length - 1) {
                    const dx = mouseX - casaState.lastX;
                    const dy = mouseY - casaState.lastY;
                    
                    casaState.puntos[casaState.dragIndex].x += dx;
                    casaState.puntos[casaState.dragIndex].y += dy;
                    
                    casaState.lastX = mouseX;
                    casaState.lastY = mouseY;
                }
            });
            
            canvas.addEventListener('mouseup', function() {
                casaState.dragging = false;
                casaState.dragIndex = -1;
            });
            
            canvas.addEventListener('mouseleave', function() {
                casaState.dragging = false;
                casaState.dragIndex = -1;
            });
            
            // Botón para reiniciar
            restartButton.addEventListener('click', function() {
                restartButton.style.display = 'none';
                initHouse();
            });
        }
        
        // Configurar el audio para detector el volumen
        function setupAudio() {
            // Solicitar acceso al micrófono
            navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                .then(function(stream) {
                    // Actualizar estado del micrófono
                    micStatus.textContent = 'Micrófono: Activado';
                    
                    // Crear el audio context
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    microphone = audioContext.createMediaStreamSource(stream);
                    
                    // Conectar el micrófono al analizador
                    microphone.connect(analyser);
                    analyser.fftSize = 256;
                    
                    // Crear un nodo JavaScript para procesar los datos de audio
                    javascriptNode = audioContext.createScriptProcessor(2048, 1, 1);
                    analyser.connect(javascriptNode);
                    javascriptNode.connect(audioContext.destination);
                    
                    // Procesar los datos de audio para detectar volumen
                    javascriptNode.onaudioprocess = function() {
                        const array = new Uint8Array(analyser.frequencyBinCount);
                        analyser.getByteFrequencyData(array);
                        
                        // Calcular el promedio del volumen
                        let values = 0;
                        const length = array.length;
                        for (let i = 0; i < length; i++) {
                            values += array[i];
                        }
                        
                        const average = values / length;
                        
                        // Usar el volumen para inflar la casa
                        const normalizedVolume = average / 128; // Normalizar a un rango aproximado de 0-1
                        
                        // Inflar según el volumen
                        if (normalizedVolume > 0.1) { // Umbral mínimo para evitar ruido de fondo
                            casaState.inflation += normalizedVolume * 0.02;
                            
                            // Limitar la inflación máxima
                            if (casaState.inflation > 1) {
                                casaState.inflation = 1;
                            }
                        }
                    };
                })
                .catch(function(err) {
                    console.log('Error accediendo al micrófono: ' + err);
                    micStatus.textContent = 'Micrófono: Error de acceso';
                });
        }
        
        // Bucle principal
        function gameLoop() {
            updateHouse();
            drawHouse();
            requestAnimationFrame(gameLoop);
        }
        
        // Inicializar todo
        function init() {
            initHouse();
            setupMouseEvents();
            setupAudio();
            gameLoop();
        }
        
        // Iniciar cuando se cargue la página
        window.onload = init;
    </script>
</body>
</html>
